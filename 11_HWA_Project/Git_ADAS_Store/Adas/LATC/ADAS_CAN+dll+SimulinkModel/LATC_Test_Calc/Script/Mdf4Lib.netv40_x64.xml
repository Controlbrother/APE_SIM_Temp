<?xml version="1.0"?>
<doc>
    <assembly>
        "Mdf4Lib.net"
    </assembly>
    <members>
        <member name="M:Vector.Mdf4LibDotNet.VMdf4Lib.GetFileManager">
            <summary>
                <para>Returns managed pointer for IFileManager interface</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.VMdf4Lib.Init(System.String,System.String,System.String,Vector.Mdf4LibDotNet.IAssertCallback,System.Boolean,System.Boolean,System.Collections.Generic.IDictionary`2{System.String,System.String})">
            <summary>
                <para>Init for MDF4 Lib wrapper</para>
            </summary>
            <param name="customerName">customerName string with customer name as given with registration information when purchasing the library.</param>
            <param name="serialNo">serialNumber string with serial number as given with registration information when purchasing the library.</param>
            <param name="regKey">registrationKey string with registration key as given with registration information when purchasing the library.</param>
            <param name="assertCallback">
                <para>assertCallback pointer to IMAssertCallback that will from now on receive asserts. null to unregister callback.</para>
                <para>See also ::SetAssertCallback.</para>
                <para>Default: null</para>
            </param>
            <param name="initCOM">
                <para>initCOM true if COM must be initialized by MDF4Lib, false if this has already been done by callee.</para>
                <para>See also ::SetCoInitializeParameters.</para>
                <para>Default: true</para>
            </param>
            <param name="multithreadedCOM">
                <para>multithreadedCOM true if ::CoInitializeEx will be called with COINIT_MULTITHREADED, otherwise with COINIT_APARTMENTTHREADED.</para>
                <para>only relevant if initCOM is true.</para>
                <para>See also Microsoft documentation on ::CoInitializeEx.</para>
                <para>Default: true (= COINIT_MULTITHREADED)</para>
            </param>
            <param name="renameMap">
                <para>map when renaming underlying C++ DLLs, e.g. when installing different versions of MDF4 Lib in same folder.</para>
                <para>Key is the original name, value the renamed DLL. For example Mdf4Libu_x64.dll could be mapped to Mdf4Libu_x64_v1.dll.</para>
                <para>only relevant if initCOM is true.</para>
            </param>
            <returns>eOK on success</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.VMdf4Lib.Init(System.String,System.String,System.String,Vector.Mdf4LibDotNet.IAssertCallback,System.Boolean,System.Boolean)">
            <summary>
                <para>Init for MDF4 Lib wrapper</para>
            </summary>
            <param name="customerName">customerName string with customer name as given with registration information when purchasing the library.</param>
            <param name="serialNo">serialNumber string with serial number as given with registration information when purchasing the library.</param>
            <param name="regKey">registrationKey string with registration key as given with registration information when purchasing the library.</param>
            <param name="assertCallback">
                <para>assertCallback pointer to IMAssertCallback that will from now on receive asserts. null to unregister callback.</para>
                <para>See also ::SetAssertCallback.</para>
                <para>Default: null</para>
            </param>
            <param name="initCOM">
                <para>initCOM true if COM must be initialized by MDF4Lib, false if this has already been done by callee.</para>
                <para>See also ::SetCoInitializeParameters.</para>
                <para>Default: true</para>
            </param>
            <param name="multithreadedCOM">
                <para>multithreadedCOM true if ::CoInitializeEx will be called with COINIT_MULTITHREADED, otherwise with COINIT_APARTMENTTHREADED.</para>
                <para>only relevant if initCOM is true.</para>
                <para>See also Microsoft documentation on ::CoInitializeEx.</para>
                <para>Default: true (= COINIT_MULTITHREADED)</para>
            </param>
            <returns>eOK on success</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.VMdf4Lib.Init(System.String,System.String,System.String)">
            <summary>
                <para>Init for MDF4 Lib wrapper</para>
            </summary>
            <param name="customerName">customerName string with customer name as given with registration information when purchasing the library.</param>
            <param name="serialNo">serialNumber string with serial number as given with registration information when purchasing the library.</param>
            <param name="regKey">registrationKey string with registration key as given with registration information when purchasing the library.</param>
            <returns>eOK on success</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.VMdf4Lib">
            <summary>
                <para>Helper class that opens Mdf4Lib from current module location in Init and closes it in destructor</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetBlockStartAddress">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetBlockStartAddress(System.UInt32@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetBlockStartAddress(System.UInt32@)">
            <summary>
Get start addresses of block representing the event and optional internal index of event within this block
<para>Note: for MDF4, this is the address of the respective EV block, for MDF3 it can be the address of a TR or a CN block, depending on the event type</para></summary>
            <param name="indexOfEventInBlock">[out] the zero-based index of the event within the block will be returned.
            <br />This is only relevant for MDF3 where a TR or CN block may contain several events.
            <br />For MDF4 EV block, this will always return 0.</param>
            <returns>start address of respective EV/TR/CN block for this event, -1 on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetGroupScope(Vector.Mdf4LibDotNet.IChannelGroup[])">
            <summary>
Set or change the group scope of event
This sets or changes the scope list of an event to scope type eScopeGroup.
<para>Note: Only available for newly created or writable file,
not possible for a range end event that reference a range begin event or if there is a parent event with global scope.</para></summary>
            <param name="channelGroupList">[in] list of IChannelGroup objects to assign as in scope list (must not be null).
Note: all channel group objects must be in the same file</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetChannelScope(Vector.Mdf4LibDotNet.IChannel[])">
            <summary>
Set or change the channel scope of event.
This sets or changes the scope list of an event to scope type eScopeChannel.
<para>Note: Only available for newly created or writable file,
not possible for a range end event that reference a range begin event or if there is a parent event with global scope.</para></summary>
            <param name="channelList">[in] list of IChannel objects to assign as in scope list (must not be null).
Note: all channel objects must be in the same file</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.RemoveAllAttachmentRefsTo(Vector.Mdf4LibDotNet.IAttachment)">
            <summary>
Remove all references to the given attachment.
<para>Note: Only available for newly created or writable file, not available for MDF version &lt; 4.0.</para>
Keep in mind that the indices of other event attachments may change.
</summary>
            <param name="attachment">[in] pointer to IAttachment object (must not be null).
Note: attachment object must be in the same file and in global list of attachments.</param>
            <returns>error code of the operation, eNotFound if the attachment was not referenced by this event.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.RemoveAttachmentRef(System.UInt64)">
            <summary>
Remove attachment reference of given index.
<para>Note: Only available for newly created or writable file, not available for MDF &lt; 4.0.</para>
Keep in mind that the indices of other event attachments may change.
</summary>
            <param name="index">[in] index of attachment in event attachments.</param>
            <returns>error code of the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.AddAttachment(Vector.Mdf4LibDotNet.IAttachment,System.UInt64@)">
            <summary>
Add attachment reference to this event.
<para>Note: Only available for newly created or writable file, not available for MDF version &lt; 4.0.</para></summary>
            <param name="attachment">[in] pointer to IAttachment object (must not be null).
Note: attachment object must be in the same file and in global list of attachments.
It is not possible to add an attachment a second time for an event.</param>
            <param name="index">[out] the zero-based index of the added attachment in the list of event attachments will be returned.</param>
            <returns>error code of the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetParentEvent(Vector.Mdf4LibDotNet.IEvent)">
            <summary>
Set or remove a reference to parent event.
If the event has a range event (see GetRangeEvent()), the parent of the range event is also set or removed.
If a parent event is specified, the current event (and its range event) will inherit the scope of the parent event
unless they have a own scope list.
The scope of the parent event must be larger or equal to the scope of its child events.
There must be no circular dependencies for the parent hierarchy.
Note: Only available for newly created or writable file.
</summary>
            <param name="parentEvent">[in] pointer to IEvent object to assign as parent event, null to remove the reference to the parent event.
Note: object must be in the same file.</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetRangeEnd(Vector.Mdf4LibDotNet.IEvent)">
            <summary>
Change this event to a range end event and optionally assign a reference to a matching range begin event.
This changes the range type of the event to eRangeEnd (see GetRangeType()).
Optionally a matching range begin event can be assigned (see GetRangeEvent()).
If a range begin event is specified, the current event must not have a scope list because it
will inherit the scope of the range begin event.
<para>In addition, the range begin event must have:</para><para>range type eRangeBegin.</para><para>the same event type as the current event (see GetType()).</para><para>the same synchronization type as the current event (see GetSyncType()).</para><para>a sync value less or equal to the current event (see GetSyncValue()).</para><para>the same parent event as the current event.</para><para>Note: Only available for newly created or writable file, not possible for a range begin event (range type eRangeBegin).</para></summary>
            <param name="rangeBegin">[in] pointer to IEvent object to assign as begin event, null to remove the reference to the range begin event.
Note: object must be in the same file.</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetRangeBegin">
            <summary>
Change this event to a range begin event.
This changes the range type of event to eRangeBegin (see GetRangeType()).
Note: Only available for newly created or writable file, not possible for a range end event (range type eRangeEnd).
</summary>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetIsPostProcessing(System.Boolean)">
            <summary>
Change post processing flag of event.
Note: Only available for newly created or writable file.
</summary>
            <param name="isPostProcessing">[in] boolean value for the flag (true to mark this event as post processing event).</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetSyncValue(System.Double)">
            <summary>
Set/change synchronization value of event.
Note: Only available for newly created or writable file.
Note: The unit of syncValue depends on the synchronization type (see GetSyncType()).
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncValue" /></summary>
            <param name="syncValue">[in] value to use as synchronization value.
Internally, this value will be set as syncFactor and syncBase will be 1.</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetSyncValue(System.Int64,System.Double)">
            <summary>
Set/change synchronization value of event.
Note: Only available for newly created or writable file.
Note: It is not allowed that both syncBase and syncFactor are zero.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncValue" /></summary>
            <param name="syncBase">[in] base value to use (<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncBaseValue" />).</param>
            <param name="syncFactor">[in] factor to use (<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncFactor" />).</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetSyncType(Vector.Mdf4LibDotNet.SyncType)">
            <summary>
Set/change synchronization type of event.
Note: Only available for newly created or writable file.
</summary>
            <param name="syncType">[in] synchronization type to use (<see cref="T:Vector.Mdf4LibDotNet.SyncType" />).
Note that only values eTimeSync, eAngleSync, eDistanceSync, eIndexSync are allowed, but eIndexSync cannot be used for
events with global scope.</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
Set comment of event.
Note: Only available for newly created or writable file.
</summary>
            <param name="comment">[in] IComment object, null to remove reference to a comment object.
Note: object must be in the same file and if comment is XML for MDF version &gt;= 4.0, it should match the respective XML schema (ev_comment.XSD).</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.SetName(System.String)">
            <summary>
Set the name for event.
Note: Only available for newly created or writable file, not available for MDF version &lt; 4.0.
</summary>
            <param name="name">[in] string to be used as name, null or empty to delete the name.</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetAttachment(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get attachment related to this event for given index.
Note: Attachments for events are only available for MDF version &gt;= 4.0.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetAttachmentCount" /></summary>
            <param name="index">[in] index of attachment.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IAttachment object, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetAttachmentCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of attachments related to this event.
Note: There can be attachments for event for MDF version &gt;= 4.0.
<para>See <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></para></summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of attachments (0 on error or if not available, e.g. for MDF version &lt; 4.0).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.IsInScope(Vector.Mdf4LibDotNet.IChannel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.IsInScope(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.IsInScope(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Check if given channel is in scope of event.
Note: This works also if channel has scope type eScopeGroup.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeType" /></summary>
            <param name="channel">[in] channel to use for this operation.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>true if channel is in scope of the event or if event has global scope, otherwise or on error false (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListGroupItem(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListGroupItem(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListGroupItem(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get channel group in scope list of this event for given index.
Note: This method only returns a valid value if the scope type is eScopeGroup.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListCount" /> and <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeType" /></summary>
            <param name="index">[in] index of element in scope list.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannelGroup object, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListChannelItem(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListChannelItem(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListChannelItem(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get channel in scope list of this event for given index.
Note: This method only returns a valid value if the scope type is eScopeChannel.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListCount" /> and <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeType" /></summary>
            <param name="index">[in] index of element in scope list.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannel object, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeListCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the number of elements in the scope list.
<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetScopeType" /></summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of elements in scope list, 0 on error or if event has a global scope (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetScopeType">
            <summary>
Get scope type of event.
In MDF4, an event can have global scope (eScopeFileGlobal) or its
scope is restricted to certain channels or channels groups. The scope is
defined by either a list of channels (eScopeChannel)
or a list of channel groups (eScopeGroup).
Depending on the scope type, either use GetScopeListChannelItem() or GetScopeListGroupItem()
to retrieve the channels or channel groups this event applies to.
</summary>
            <returns>scope type, <see cref="T:Vector.Mdf4LibDotNet.ScopeType" />, eScopeTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.HasGlobalScope">
            <summary>
Check if event has global scope, i.e. applies to the complete file.
This is the same as when GetScopeType() returns eScopeFileGlobal.
</summary>
            <returns>true if event has a global scope, false otherwise.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.IsPostProcessing">
            <summary>
Check if event is a post processing event.
Note: Post processing flag is only available for MDF version &gt;= 4.0.
</summary>
            <returns>true if this event was generated by post processing, false otherwise.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetParentEvent">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetParentEvent(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetParentEvent(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the parent event of current event.
Event parents can be used to structure events. Another use case is to avoid settings the scope for
each of the child events because if no scope is defined for the child event (empty scope list), then
the child event inherits the scope of its parent event.
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IEvent object, null on error or if not available (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetRangeEvent">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetRangeEvent(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetRangeEvent(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the range partner event for a range begin or end event.
Note: Two events can form a range (see GetRangeType()). A range begin or range end event may also occur without a partner event.
If there is a range partner, the range end event will inherit the scope of the range
begin event and both events must have the same parent event.
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IEvent object, null on error or if not available (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetCreatorInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get information about creator of event.
<see cref="M:Vector.Mdf4LibDotNet.IFile.GetCreatorInfo" /></summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to ICreatorInfo object, null on error or for MDF version &lt;= 4.0.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetPostTrigInterval">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetPostTrigInterval(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetPostTrigInterval(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get post-trigger interval for trigger event as specified in the tool.
Note: The post-trigger interval is optional and its unit depends on the synchronization type (see GetSyncType()).
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>post-trigger interval, 0.0 on error or if not available (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetPreTrigInterval">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetPreTrigInterval(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetPreTrigInterval(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get pre-trigger interval for trigger event as specified in the tool.
Note: The pre-trigger interval is optional and its unit depends on the synchronization type (see GetSyncType()).
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pre-trigger interval, 0.0 on error or if not available (check error code).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetSyncFactor">
            <summary>
Get sync factor of event.
The sync factor is used for calculation of the synchronization value (see GetSyncValue()).
</summary>
            <returns>sync factor.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetSyncBaseValue">
            <summary>
Get sync base value of event.
The sync base value is used for calculation of the synchronization value (see GetSyncValue()).
</summary>
            <returns>sync base value.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetSyncValue">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncValue(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetSyncValue(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get synchronization value of event.
The synchronization value (or sync value) is calculated by multiplication of the sync base value and the sync factor
(<see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncBaseValue" /> and <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetSyncFactor" />). Its unit depends on the synchronization type (GetSyncType()).
The sync value specifies when the event occurred (relative to start sync value of file). Typically time is used for synchronization.
Note: The separation into a base value and a factor has the advantage that a higher precision can be achieved.
For example, when using for time master channels nanoseconds as raw value, the sync base value could be in nanoseconds
and the sync factor 1e-9. Thus it is possible to compare the nanoseconds directly.
Vice versa, a sync base value of 1 could be used to store the time stamp in seconds directly as double as sync factor.
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>sync value, 0.0 on error (check error code for warnings).</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetSyncType">
            <summary>
Get synchronization type of event.
</summary>
            <returns>sync type, <see cref="T:Vector.Mdf4LibDotNet.SyncType" />, eSyncTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetRangeType">
            <summary>
Get range type of event.
The range type specifies if this is a single event (ePoint)
or if it is the begin or end of a range. See also GetRangeEvent().
</summary>
            <returns>range type, <see cref="T:Vector.Mdf4LibDotNet.RangeType" />, eRangeTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetCause">
            <summary>
Get cause of event.
</summary>
            <returns>event type, <see cref="T:Vector.Mdf4LibDotNet.EventCause" />, eEventCauseUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetType">
            <summary>
Get type of event.
</summary>
            <returns>event type, <see cref="T:Vector.Mdf4LibDotNet.EventType" />, eEventTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment of event.
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IComment object, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEvent.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get name of event.
Note: Only available for MDF version &gt;= 4.0.
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with event name, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEvent.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IEvent">
            <summary>
                <para>Description of an event</para>
                <para>The IEvent object describes an event and its properties. There are different types of events:</para>
                <para>events that influenced the recording, such as begin, end or an interruption</para>
                <para>conditional events, i.e. triggers</para>
                <para>markers, i.e. comments related to a point in time or a time range</para>
                <para>Each event contains a time stamp (or - more generally - a synchronization value) for synchronization
with other events or channel groups.</para>
                <para>Usually an event defines a "point" in time, but for some event types, two events can be linked to define a time "range". See IEvent::GetRangeType() and IEvent::GetRangeEvent()</para>
                <para>The "Scope" of the event defines which channels it applies to. An event can have global scope (event applies to the complete file)
or it can only apply to one or more channels or channel groups (i.e. then to all channels in the respective group). See IEvent::GetScopeType().
There are special rules for the scope of events that have a parent event or that are the end of a range (range type eRangeEnd).</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetEventSubSet(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEventSet.GetEventSubSet(System.String,Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetEventSubSet(System.String,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEventSet.GetEventSubSet(System.String,Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetEventSubSet(System.String,Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get a sub set with all events matching the given parameters
</summary>
            <param name="eventName">[in] name of event to find. If null, the name is not considered for filtering.
If the eUseEventNameAsMask bit is set in filterFlags, the string is a search mask with wild cards.
The wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.
If the eAcceptIfNoEventName bit is set in options, events without an extended name prefix are accepted.</param>
            <param name="filterFlags">[in] flags for filtering, value is a bit combination of EventFilterFlags</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IEventSet object, null on error </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetEventByIndex(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IEventSet.GetEventByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetEventByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get event from set for given index
</summary>
            <param name="index">[in] index of element</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IEvent object, null on error </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetCount">
            <summary>
Get number of events in set
</summary>
            <returns> number of events, 0 if empty or on error </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IEventSet.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IEventSet">
            <summary>
                <para>Collection of events</para>
                <para>The IEventSet object contains a number of events.</para>
                <para>It can be used to filter events associated to a file, a channel group or a channel.</para>
                <para>The events in the set are always sorted by their synchronization value (usually time stamp).</para>
                <para>They can be accessed by zero-based index in the set.</para>
                <para>Further methods allow to filter the events from the set into a new subset.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetComparisonQuantityChannel(Vector.Mdf4LibDotNet.IChannel)">
            <summary>
Set comparison quantity channel for the array
Note: only available for MDF4
The comparison quantity channel should have the same physical unit as the array elements.
(currently not checked by MDF4 Lib).
</summary>
            <param name="channel">[in] IChannel object to be set as comparison quantity, null to remove reference for it.
Note: channel object must be in the same file.
Since the comparison quantity channel and the array channel must be synchronized, their channel
groups must contain at least one common master channel type.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetComparisonQuantityChannel">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetComparisonQuantityChannel(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetComparisonQuantityChannel(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comparison quantity channel for the array
Note: only available for MDF4
</summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IChannel object for the comparison quantity channel, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetOutputQuantityChannel(Vector.Mdf4LibDotNet.IChannel)">
            <summary>
Set output quantity channel for the array
Note: only available for MDF4
The output quantity channel should have the same physical unit as the array elements.
(currently not checked by MDF4 Lib).
</summary>
            <param name="channel">[in] IChannel object to set as output quantity, null to remove reference for it.
Note: channel object must be in the same file.
Since the output quantity channel and the array channel must be synchronized, their channel
groups must contain at least one common master channel type.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetOutputQuantityChannel">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetOutputQuantityChannel(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetOutputQuantityChannel(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get output quantity channel for the array
Note: only available for MDF4
</summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IChannel object for the output quantity channel, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetInputQuantityChannel(System.UInt16,Vector.Mdf4LibDotNet.IChannel)">
            <summary>
Set input quantity ("working point") channel for given dimension
Note: only available for MDF4
The input quantity channel should have the same physical unit as the axis it is applied to.
(currently not checked by MDF4 Lib).
</summary>
            <param name="dimension">[in] dimension index of dimension</param>
            <param name="channel">[in] IChannel object to set as input quantity, null to remove reference for it.
Note: channel object must be in the same file.
Since the input quantity channel and the array channel must be synchronized, their channel
groups must contain at least one common master channel type.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetInputQuantityChannel(System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetInputQuantityChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetInputQuantityChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get input quantity ("working point") channel for given dimension
Note: only available for MDF4
</summary>
            <param name="dimension">[in] dimension index of dimension</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IChannel object for the input quantity channel, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetDynamicSizeChannel(System.UInt16,Vector.Mdf4LibDotNet.IChannel)">
            <summary>
Set dynamic size channel for given dimension
Note: only available for MDF4
The physical value of a dynamic size channel must be numeric
(Ideally the channel has no conversion rule and an unsigned integer data type)
It should not exceed the maximum number of dimensions as given by GetDimSize
(currently not checked by MDF4 Lib).
</summary>
            <param name="dimension">[in] dimension index of dimension</param>
            <param name="channel">[in] IChannel object to set as dynamic size channel, null to remove reference for it.
Note: channel object must be in the same file.
Since the dynamic size channel and the array channel must be synchronized, their channel
groups must contain at least one common master channel type.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDynamicSizeChannel(System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDynamicSizeChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDynamicSizeChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get dynamic size channel for given dimension
A dynamic size channel is used if the number of elements for a dimension can vary over time.
Its (physical) value at a specific instant of time specifies the number of elements.
This is valid until the value of dynamic size channel changes. See also GetDimSize().
Note: only available for MDF4
</summary>
            <param name="dimension">[in] dimension index of dimension</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IChannel object for the dynamic size channel, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetFixAxisRawValues(System.UInt16,System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetFixAxisRawValues(System.UInt16,System.Double[]@,System.UInt64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetFixAxisRawValues(System.UInt16,System.Double[]@,System.UInt64)">
            <summary>
Get raw values of fixed axis for given dimension.
note: only available if there are fixed axes for this array.
Axis values are given as raw values. In addition, a conversion rule can be specified for conversion to physical values (see GetAxisConversion).
If no a axis conversion is present, the physical values are identical to the raw values (1:1 conversion).
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="rawValueArray">[in] array buffer to receive the result values (must not be null).</param>
            <param name="arrayElements">[in] length of rawValueArray buffer, i.e. maximum number of values that can be stored (must not be 0).
If arrayElements &lt; dimSize, only the first arrayElements values are set and the method returns ::eInputBufferTooSmall.
If arrayElements &gt; dimSize, only the first dimSize values are set.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetFixAxisRawValues(System.UInt16,System.Double[],Vector.Mdf4LibDotNet.IConversion)">
            <summary>
Set raw values of fixed axis for given dimension.
note: only available if there are fixed axes for this array.
note: creating an array object (see IChannel::ConverterToArray) with fixed axis, the fixed axis values are automatically initialized with the indizes of the axis (0, 1, 2, ...).
Axis values are given as raw values. In addition, a conversion rule can be specified for conversion to physical values (alternatively use SetAxisConversion).
If no a axis conversion is present, the physical values are identical to the raw values (1:1 conversion).
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="rawValueArray">[in] array with raw values to be set for the fixed axis (must not be null and must not be 0).
If number of elements &lt; dimSize, only the first elements values are set and the method returns ::eInputBufferTooSmall.
If number of elements &gt; dimSize, only the first dimSize values are set.</param>
            <param name="conversion">[in] IConversion object to be set for the axis. If null, the axis conversion is not changed (leave existing link).
Note: conversion object must be in the same file</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetAxisConversion(System.UInt16,Vector.Mdf4LibDotNet.IConversion)">
            <summary>
Set conversion of axis for given dimension.
note: only available for MDF4 and if there are axes for this array.
In case of a fixed axis, the axis conversion is used to get the physical axis values. If not specified, the physical values are identical to the raw values.
In case of a dynamic axis, the axis conversion must be applied to the raw values of the axis channel (overrules the conversion of the axis channel).
If not specified, the raw axis values can be used as physical value (1:1 conversion).
However, typically, the axis conversion is identical to the conversion of the axis channel.
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="conversion">[in] IConversion object to be set for the axis, null to remove reference for this axis conversion.
Note: conversion object must be in the same file</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisConversion(System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisConversion(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisConversion(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get conversion of axis for given dimension.
note: only available for MDF4 and if there are axes for this array.
In case of a fixed axis, the axis conversion is used to get the physical axis values. If not specified, the physical values are identical to the raw values.
In case of a dynamic axis, the axis conversion must be applied to the raw values of the axis channel (overrules the conversion of the axis channel).
If not specified, the raw axis values can be used as physical value (1:1 conversion).
However, typically, the axis conversion is identical to the conversion of the axis channel.
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> IConversion object to be used for the axis, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.SetAxisChannel(System.UInt16,Vector.Mdf4LibDotNet.IChannel)">
            <summary>
Set axis channel for given dimension.
note: only available for newly created or writable file and if the ::eHasAxis flag was set and ::eHasFixedAxis flag is not set for given dimension.
For MDF4, if the axis has a conversion, the same rule will be set as axis conversion (see GetAxisConversion).
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="channel">[in] IChannel object to set as axis, null to remove reference for this axis.
Note: channel object must be in the same file and must be a 1-dimensional array of type ::eIsScalingAxis or ::eIsIntervalAxis (later only for ::eIsClassificationResult array type)</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisChannel(System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetAxisChannel(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get axis channel for given dimension
note: in case of fixed axis, an axis channel is not available.
Remember to check if there is a separate conversion rule specified for this axis (see GetAxisConversion).
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> IChannel object for the axis, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimSize(System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimSize(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimSize(System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of elements for given dimension.
Note: in case there is a dynamic size channel for this dimension, then this is the maximum number of elements possible.
The actual number of elements is specified by the physical value of the dynamic size channel at the same time.
</summary>
            <param name="dimension">[in] index of dimension</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> number of elements for given dimension, 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetDimCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of dimensions of the array
</summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> number of dimensions, 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IArrayInfo.GetType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get type of array
</summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> type of array, eArrayTypeUnspec on error. See ArrayType</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IArrayInfo.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IArrayInfo">
            <summary>
Information about array properties of an array channel
The IArrayInfo object serves to access or modify special array properties of a channel.
For MDF3, arrays are stored with a CD block, for MDF4 with one or more CA blocks.
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IValidateFileCallback.OnWarning(System.String,System.String,System.String,Vector.Mdf4LibDotNet.MessageTypeValidateCallback)">
            <summary>
Called when the file validation reports a warning
note: warning messages will only be posted if ::eReportWarnings bit is set in options for call to IFileManager::ValidateFile.
note: All strings provided are only valid until the method returns. In case they should be used later, it is essential to copy them.
</summary>
            <param name="message">[in] message for the warning</param>
            <param name="nodeName">[in] name of the node the warning is related to, null if there is no relation to a node</param>
            <param name="propertyName">[in] name of the property the warning is related to, null if there is no relation to a property</param>
            <param name="messageType">[in] the message type (currently always eMessageTypeUnspecified)</param>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IValidateFileCallback.OnError(System.String,System.String,System.String,Vector.Mdf4LibDotNet.MessageTypeValidateCallback)">
            <summary>
Called when the file validation reports an error
note: All strings provided are only valid until the method returns. In case they should be used later, it is essential to copy them.
</summary>
            <param name="message">[in] message for the error</param>
            <param name="nodeName">[in] name of the node the error is related to, null if there is no relation to a node</param>
            <param name="propertyName">[in] name of the property the error is related to, null if there is no relation to a property</param>
            <param name="messageType">[in] message type (currently always eMessageTypeUnspecified)</param>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IValidateFileCallback">
            <summary>
Callback interface for IFileManager::ValidateFile
The callback receives the errors and warnings reported during validation of the MDF file.
This may be used to filter for specific errors/warnings and to report (log or display) them.
note: The log messages and error/warning levels are the same as in the error log of Vector MDF Validator.
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.GetXml">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IUnit.GetXml(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.GetXml(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get plain XML string (only if IsXml() is true)
</summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>return pointer to XML string</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.IsXml">
            <summary>
Request if unit is XML string
</summary>
            <returns>return true if unit is XML string (MDBLOCK in MDF4 only)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IUnit.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get name of unit (contents of TXBLOCK or contents of &lt;TX&gt; tag for MDBLOCK)</para>
                <para>note: for MDF4 channel data types eMimeSample and eMimeStream, the name of IUnit of the channel specifies the MIME type</para>
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>return pointer to text</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IUnit.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IUnit">
            <summary>
                <para>Unit of a channel or a conversion</para>
                <para>The IUnit object contains the unit name and possibly description of a physical unit.</para>
                <para>It can be a plain text or (for MDF4) also an XML fragment.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimePartsForRelativeTimeSec(System.Double,System.Boolean,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
Get single parts of the time stamp for a relative time given as offset in seconds
</summary>
            <param name="offsetSec">[in] relative time in seconds, i.e. offset to be added to the absolute time represented by this object. The ITimeStamp object will not be changed!</param>
            <param name="localTime">
                <para>[in] localTime if true, the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="year">[out] year, this argument will receive the year number, e.g. 2011</param>
            <param name="month">[out] month, this argument will receive the month number (1-12)</param>
            <param name="day">[out] day, this argument will receive the day number (1-31)</param>
            <param name="hour">[out] hour, this argument will receive the hour number (0-23)</param>
            <param name="minute">[out] minute, this argument will receive the minute number (0-59)</param>
            <param name="second">[out] second, this argument will receive the second number (0-59)</param>
            <param name="ns">[out] ns, this argument will receive the nanosecond number (0-999999999)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimePartsForRelativeTimeNs(System.Int64,System.Boolean,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
Get single parts of the time stamp for a relative time given as offset in nanoseconds
</summary>
            <param name="offsetNs">[in] relative time in ns, i.e. offset to be added to the absolute time represented by this object. The ITimeStamp object will not be changed!</param>
            <param name="localTime">
                <para>[in] localTime if true, the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="year">[out] year, this argument will receive the year number, e.g. 2011</param>
            <param name="month">[out] month, this argument will receive the month number (1-12)</param>
            <param name="day">[out] day, this argument will receive the day number (1-31)</param>
            <param name="hour">[out] hour, this argument will receive the hour number (0-23)</param>
            <param name="minute">[out] minute, this argument will receive the minute number (0-59)</param>
            <param name="second">[out] second, this argument will receive the second number (0-59)</param>
            <param name="ns">[out] ns, this argument will receive the nanosecond number (0-999999999)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeSec(System.Double)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeSec(System.Double,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeSec(System.Double,System.Boolean,System.Boolean,System.Boolean,System.Byte)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeSec(System.Double,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeSec(System.Double,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get a formatted string with absolute time stamp for a relative time given as offset in seconds</para>
                <para>The full format will be YYYY-MM-DD hh-mm-ss.nnnnn GMT where</para>
                <para>YYYY is the year</para>
                <para>MM is the month number</para>
                <para>DD is the day</para>
                <para>ff is the hour (24 hr system)</para>
                <para>mm is the minute</para>
                <para>ss is the second</para>
                <para>nnnnn is the nanosecond (number of decimal places given in decimalPlacesForNs)</para>
                <para>GMT is the time zone offset, e.g. GMT+1, GMT or GMT-4</para>
            </summary>
            <param name="offsetSec">[in] relative time in seconds, i.e. offset to be added to the absolute time represented by this object. The ITimeStamp object will not be changed!</param>
            <param name="localTime">
                <para>[in] localTime if true (default), the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="addDate">[in] addDate if true (default), not only the time but also the date will be contained in the formatted string</param>
            <param name="addTimeZone">[in] addTimeZone if true, the time zone information will be appended. Default is false.</param>
            <param name="precisionForNs">[in] precisionForNs number of decimal places for nanoseconds (max 9). 0 if nanoseconds should be omitted.</param>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to formatted string or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeNs(System.Int64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeNs(System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeNs(System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Byte)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeNs(System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStringForRelativeTimeNs(System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get a formatted string with absolute time stamp for a relative time given as offset in nanoseconds</para>
                <para>The full format will be YYYY-MM-DD hh-mm-ss.nnnnn GMT where</para>
                <para>YYYY is the year</para>
                <para>MM is the month number</para>
                <para>DD is the day</para>
                <para>ff is the hour (24 hr system)</para>
                <para>mm is the minute</para>
                <para>ss is the second</para>
                <para>nnnnn is the nanosecond (number of decimal places given in decimalPlacesForNs)</para>
                <para>GMT is the time zone offset, e.g. GMT+1, GMT or GMT-4</para>
            </summary>
            <param name="offsetNs">[in] relative time in ns, i.e. offset to be added to the absolute time represented by this object. The ITimeStamp object will not be changed!</param>
            <param name="localTime">
                <para>[in] localTime if true (default), the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="addDate">[in] addDate if true (default), not only the time but also the date will be contained in the formatted string</param>
            <param name="addTimeZone">[in] addTimeZone if true, the time zone information will be appended. Default is false.</param>
            <param name="precisionForNs">[in] precisionForNs number of decimal places for nanoseconds (max 9). 0 if nanoseconds should be omitted.</param>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to formatted string or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetFlags">
            <summary>
Get time flags
</summary>
            <return>flags of the time stamp</return>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.AreOffsetsValid">
            <summary>
                <para>Request if time zone and daylight saving time offsets are valid</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetFlags" />, <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeZoneOffset(Vector.Mdf4LibDotNet.ErrorCode@)" />, <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetDaylightSavingTimeOffset(Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <return>true if both offsets are valid, otherwise false</return>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.IsLocalTime">
            <summary>
                <para>Request if time stamp is local time</para>
                <para>If true, the start time stamp in nanoseconds represents the local time instead of the UTC time</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStampNs(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <return>true if time stamp is local time, otherwise false</return>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetDaylightSavingTimeOffset">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetDaylightSavingTimeOffset(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetDaylightSavingTimeOffset(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the daylight saving time (DST) offset in minutes</para>
                <para>note Only valid if AreOffsetsValid returns true</para>
                <para>During the summer months, most regions observe a DST offset of 60 min (1 hour).</para>
                <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.AreOffsetsValid" />
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <return>daylight saving time offset in minutes or 0 in case of error or if time zone offset is invalid/unknown</return>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeZoneOffset">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeZoneOffset(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeZoneOffset(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the time zone offset in minutes</para>
                <para>note Only valid if AreOffsetsValid returns true</para>
                <para>The value is in range [-720,720], i.e. it can be negative!</para>
                <para>For example a value of 60 (min) means UTC+1 time zone = Central European Time (CET).</para>
                <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.AreOffsetsValid" />
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <return>time zone offset in minutes or 0 in case of error or if time zone offset is invalid/unknown</return>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeParts(System.Boolean,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
Get single parts of the time stamp
</summary>
            <param name="localTime">
                <para>[in] localTime if true, the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="year">[out] year, this argument will receive the year number, e.g. 2011</param>
            <param name="month">[out] month, this argument will receive the month number (1-12)</param>
            <param name="day">[out] day, this argument will receive the day number (1-31)</param>
            <param name="hour">[out] hour, this argument will receive the hour number (0-23)</param>
            <param name="minute">[out] minute, this argument will receive the minute number (0-59)</param>
            <param name="second">[out] second, this argument will receive the second number (0-59)</param>
            <param name="ns">[out] ns, this argument will receive the nanosecond number (0-999999999)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeString">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeString(System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeString(System.Boolean,System.Boolean,System.Boolean,System.Byte)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeString(System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeString(System.Boolean,System.Boolean,System.Boolean,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get a formatted string with time stamp</para>
                <para>The full format will be YYYY-MM-DD hh-mm-ss.nnnnn GMT where</para>
                <para>YYYY is the year</para>
                <para>MM is the month number</para>
                <para>DD is the day</para>
                <para>ff is the hour (24 hr system)</para>
                <para>mm is the minute</para>
                <para>ss is the second</para>
                <para>nnnnn is the nanosecond (number of decimal places given in decimalPlacesForNs)</para>
                <para>GMT is the time zone offset, e.g. GMT+1, GMT or GMT-4</para>
            </summary>
            <param name="localTime">
                <para>[in] localTime if true (default), the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="addDate">[in] addDate if true (default), not only the time but also the date will be contained in the formatted string</param>
            <param name="addTimeZone">[in] addTimeZone if true, the time zone information will be appended. Default is false.</param>
            <param name="precisionForNs">[in] precisionForNs number of decimal places for nanoseconds (max 9). 0 if nanoseconds should be omitted.</param>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to formatted string or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStampNs(System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStampNs(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetTimeStampNs(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the time stamp in nanoseconds
<see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.IsLocalTime" />, <see cref="M:Vector.Mdf4LibDotNet.ITimeStamp.AreOffsetsValid" /></summary>
            <param name="localTime">
                <para>[in] localTime if true, the local time stamp will be returned, otherwise the UTC time stamp (if available).</para>
                <para>If offsets are missing and localTime is true, the offsets of the running system are used to determine the local time.</para>
            </param>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>
                <para>time stamp in ns elapsed since 00:00:00 01.01.1970 (UTC time or local time, depending on localTime argument)</para>
                <para>0 on error</para>
            </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ITimeStamp.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ITimeStamp">
            <summary>
                <para>time stamp of a file or a file history log</para>
                <para>The ITimeStamp object contains information about a time stamp.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of source</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="comment">
                <para>[in] comment object of type IComment, null to remove reference to a comment object.</para>
                <para>Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (si_comment.XSD).</para>
            </param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.IsSimulated">
            <summary>
                <para>Request if source is only simulated</para>
                <para>note: information not available for MDF3</para>
            </summary>
            <returns>true if simulated source, otherwise false</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetBusChannelNumber">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ISourceInfo.GetBusChannelNumber(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetBusChannelNumber(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get logical bus channel number for the source info</para>
                <para>The logical bus channel is a 1-based integer number and is used to enumerate bus channels of the same type (e.g. all CAN buses).</para>
                <para>It is optional. For MDF4, it typically is contained in the acquisition source.</para>
                <para>For MDF3, it can only be contained in the channel source because there is no acquisition source.</para>
                <para>For a source type ::eSourceBus, the bus channel number relates to the monitored bus.</para>
                <para>For source type eSourceEcu it relates to the bus over which the ECU signals were transported (use case not available for MDF3).</para>
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>bus channel number or 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetBusType">
            <summary>
                <para>Get bus type of the source</para>
                <para>note: for MDF3 ce_type = DIM is mapped to eBusNone and ce_type = VCN to eBusOther</para>
                <para>for MDF4 custom or unknown bus types are mapped to eBusOther</para>
            </summary>
            <returns>bus type, see ::SourceBusTypeEnum, ::eSourceBusTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetSourceType">
            <summary>
                <para>Get type of the source</para>
                <para>note: for MDF3 ce_type = DIM is mapped to eSourceEcu and ce_type = VCN to ::eSourceBus</para>
            </summary>
            <returns>source type, see ::SourceTypeEnum, ::eSourceTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ISourceInfo.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get comment of source</para>
                <para>note: for MDF3 the description string of CE block (ce_type = DIM) or the sender name (ce_type = VCN) will be returned</para>
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetPath">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ISourceInfo.GetPath(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetPath(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get path of source</para>
                <para>note: not available for MDF3</para>
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to string with source path, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ISourceInfo.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get name of source</para>
                <para>note: for MDF3 the message name (ce_type = VCN) or the ECU identification (ce_type = DIM) will be returned</para>
            </summary>
            <param name="errorCode">[out] errorCode the error code of the operation will be returned</param>
            <returns>pointer to string with source name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ISourceInfo.GetPtr">
            <summary>
                <para>Return the underlying C++ pointer</para>
                <para>This pointer can be used to check if two managed objects point to same data block</para>
            </summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ISourceInfo">
            <summary>
                <para>Source of an acquisition or a signal</para>
                <para>The ISourceInfo object of a channel gives information about the source of the signal, e.g. the device name.</para>
                <para>For a channel group gives the ISourceInfo specifies the source of the acquisition, e.g. a bus message or also an ECU/network node.</para>
                <para>For MDF3, the ISourceInfo represents the CE block, which either holds the device name for signals from an ECU, or the bus message name and ID for signal from a bus message.</para>
                <para>For MDF4, the bus message information is contained in the source info of the channel group.</para>
                <para>In order to access the message name, use IChannel::GetMessageName.</para>
                <para>Alternatively use IChannel::GetExtendedNamePrefix in order to either get the message or the device name.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IProgressCallback.OnCheckCancel">
            <summary>
                <para>will be called when checking if user wants to cancel the task</para>
            </summary>
            <returns>
                <para>true in case user wants to cancel the task</para>
                <para>false if the task can continue</para>
            </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IProgressCallback.OnProgress(System.Byte)">
            <summary>
                <para>will be called on update of progress (e.g. for update of progress bar)</para>
                <para>will also check if user wants to cancel the task. See <see cref="M:Vector.Mdf4LibDotNet.IProgressCallback.OnCheckCancel" /></para>
            </summary>
            <param name="percentage">[in] percentage percentage of progress (0-100)</param>
            <returns>
                <para>true in case user wants to cancel the task</para>
                <para>false if the task can continue</para>
            </returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IProgressCallback.OnFinish(Vector.Mdf4LibDotNet.ErrorCode,System.String)">
            <summary>
                <para>will be called when task has finished with result and result message
(e.g. for display in a result log or (in case of error) in a dialog)</para>
            </summary>
            <param name="result">[in] result error code of task (&lt; 0 in case of critical errors)</param>
            <param name="message">[in] message result/error message</param>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IProgressCallback.OnInitialize(System.String)">
            <summary>
                <para>will be called when task starts with initialization message
(e.g. for display in task bar etc.)</para>
            </summary>
            <param name="message">[in] message initialization message</param>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IProgressCallback">
            <summary>
                <para>Callback interface to report progress of a task</para>
                <para>For long-lasting tasks (e.g. sorting of a file), you may provide a callback to receive information about the progress
of the task and to abort the task. This can be done by implementing a class that derives from this interface.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ILogSink.GetIdentifier">
            <summary>
                <para>Get the identifier of the log sink</para>
                <para>The identifier might be used to identify a log sink.</para>
                <para>However, MDF4Lib currently only uses it for debug outputs.</para>
            </summary>
            <returns>pointer to string with identifier</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ILogSink.OnLogEntry(Vector.Mdf4LibDotNet.LogSinkLevel,System.String)">
            <summary>
                <para>Called when the log sink receives a message</para>
                <para>note: MDF4Lib only logs messages with the a logging level higher or equal to the minimum level specified at registration of the log sink.</para>
                <para>see also <see cref="M:Vector.Mdf4LibDotNet.IFileManager.RegisterLogSink(Vector.Mdf4LibDotNet.ILogSink,Vector.Mdf4LibDotNet.LogSinkLevel)" /></para>
                <para>see also <see cref="M:Vector.Mdf4LibDotNet.IFile.RegisterLogSink(Vector.Mdf4LibDotNet.ILogSink,Vector.Mdf4LibDotNet.LogSinkLevel)" /></para>
                <para>see also <see cref="M:Vector.Mdf4LibDotNet.IFileManager.LogMessage(Vector.Mdf4LibDotNet.LogSinkLevel,System.String)" /></para>
            </summary>
            <param name="level">[in] level logging level for this message</param>
            <param name="msg">[in] the message to write</param>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ILogSink">
            <summary>
                <para>Callback interface for debug logging</para>
                <para>For debugging, one or more log sinks can be registered for the global IFileManager or each IFile.</para>
                <para>Own log sinks can be implemented by deriving from this interface.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.CanReadChannelValueFlags)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.CanReadChannelValueFlags)">
            <summary>
                <para>Check if values of the given channel can be read as PhysValueDouble in general</para>
                <para>This function may help to decide whether to use a MultiReadPhysValueDouble method or iterate over all records and check each result individually.
It considers the options to ignore some warnings specified at creating the IDataPointer (see IChannelGroup::CreateDataPointerEx).</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="options">[in] bit combination of option flags, see ::CanReadChannelValueFlags</param>
            <returns>error code of the operation:<br /><br />::eOK if PhysValueDouble methods can safely be used
<br />::eInvalidDataTypeForOperation if IChannel neither has not a numeric data type nor a conversion of type ::eText2Value
<br />::eDifferentCoversionResultType if IChannel has a conversion with text output
<br />::eStatusStringTableEntry if IChannel has a status string table conversion
<br />::eFatalFormatError in case of invalid conversion
<br />::eDivisionByZero or ::eLogarithmOfZero in conversion always delivers this result (still can happen for indvidualy channel values!)
<br />::eNoDataAvailable if there are no channel values
<br />... (other error codes possible)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Request the state of the invalidation bit for the given channel</para>
                <para>note: invalidation bits are not available for MDF3 and optional for MDF4</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current or the the next value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent.</para>
                <para>Note: for this method, eGetInterpolated will return the logical OR of the bit states for eGetCurrent and eGetNext.</para>
            </param>
            <returns>true if invalidation bit is set for given channel, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the raw value for the given channel as string</para>
                <para>note:</para>
                <para>Only possible for string data types.</para>
                <para>The string will be transformed to Unicode or MBCS depending on the library.</para>
                <para>The result string always is zero terminated.</para>
                <para>Please note that the bufferSize is in Bytes and not in characters.</para>
            </summary>
            <param name="channel">[in]  pChannel channel to use for this operation</param>
            <param name="stringBuffer">[out] buffer to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific size.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current or the the next value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent.</para>
                <para>Note: for this method, eGetInterpolated is equal to eGetCurrent.</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the raw value for the given channel as BYTE array</para>
                <para>note: for numeric values, the value bytes will be assigned!</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="byteArray">[out] byteArray to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific size.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current or the the next value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent.</para>
                <para>Note: for this method, eGetInterpolated is equal to eGetCurrent.</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the raw value for the given channel as Integer value</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current, the next or an interpolated value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent.</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the raw value for the given channel as double value</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current, the next or an interpolated value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent.</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the phys value for the given channel as string</para>
                <para>note:</para>
                <para>1. Only possible if conversion returns a string or 1:1 conversion for string data types.</para>
                <para>2. The string will be transformed to Unicode or MBCS depending on the library.</para>
                <para>3. The result string always is zero terminated.</para>
                <para>4. Please note that the bufferSize is in Bytes and not in characters.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="stringBuffer">[out] buffer to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific size.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current or the the next value, see ValueAccessMode.</para>
                <para>Default: eGetCurrent</para>
                <para>Note: for this method, eGetInterpolated is equal to eGetCurrent.</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@,Vector.Mdf4LibDotNet.ValueAccessMode)">
            <summary>
                <para>Read the physical value for the given channel as double value</para>
                <para>note: in case there is no conversion rule, the raw value will be returned (1:1 conversion)</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <param name="accessMode">
                <para>[in] accessMode the access mode controls whether to read the current, the next or an interpolated value. <see cref="T:Vector.Mdf4LibDotNet.ValueAccessMode" /></para>
                <para>Default: eGetCurrent</para>
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get time stamp in seconds for next position or for next position of a specific channel group</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0: get next time (time after Inc(1)).</para>
                <para>&gt;= 0: get next time of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
                <para>Note: the next time of a specific channel group may be larger than the next total time.</para>
            </param>
            <returns>time stamp in seconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetNextTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get time stamp in nanoseconds for next position or for next position of a specific channel group</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0: get next time (time after Inc(1)).</para>
                <para>&gt;= 0: get next time of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
                <para>Note: the next time of a specific channel group may be larger than the next total time.</para>
            </param>
            <returns>time stamp in nanoseconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get time stamp in seconds for current position or for a specific channel group</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0: get current time.</para>
                <para>&gt;= 0: get current time of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
                <para>Note: the current time of a specific channel group may be less than the current total time.</para>
            </param>
            <returns>time stamp in seconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get time stamp in nanoseconds for current position or for a specific channel group</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0: get current total time.</para>
                <para>&gt;= 0: get current time of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
                <para>Note: the current time of a specific channel group may be less than the current total time.</para>
            </param>
            <returns>time stamp in nanoseconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get the total number of records or the number of records for a specified channel group</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0 get total number of records (sum over all contained channel groups).</para>
                <para>&gt;= 0 get number of records of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
            </param>
            <returns>the number of records or 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@,System.Int32)">
            <summary>
                <para>Get current record position for total number of records or current position for a specified channel group contained in the IGroupDataPointer array.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="groupIndex">
                <para>[in] groupIndex &lt; 0 get record position for total number of records (zero-based number of finished records).</para>
                <para>&gt;= 0 get current position of contained channel group specified by zero-based index (see AddChannelGroup).</para>
                <para>Default: -1</para>
            </param>
            <returns>zero-based index of current record or -1 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.IncTimeSec(System.Double)">
            <summary>
                <para>Increment the current time by the specified time interval</para>
                <para>note: SeekFirst must have been called once before!</para>
                <para>IGroupDataPointer allows only forward increments. The current time will be incremented and all channel groups will be advanced accordingly.</para>
            </summary>
            <param name="timeIntervalSec">[in] timeIntervalSec time interval in seconds to advance the current time.</param>
            <returns>error code of the operation, eReachedEndOfData when IGroupDataPointer already is at or beyond last data point</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.IncTimeNs(System.UInt64)">
            <summary>
                <para>Increment the current time by the specified time interval</para>
                <para>note: SeekFirst must have been called once before!</para>
                <para>IGroupDataPointer allows only forward increments. The current time will be incremented and all channel groups will be advanced accordingly.</para>
            </summary>
            <param name="timeIntervalNs">[in] timeIntervalNs time interval in nanoseconds to advance the current time.</param>
            <returns>error code of the operation, eReachedEndOfData when IGroupDataPointer already is at or beyond last data point</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.Inc(System.UInt64)">
            <summary>
                <para>Increment the record position by given number of increments</para>
                <para>note: SeekFirst must have been called once before!</para>
                <para>IGroupDataPointer allows only forward increments.</para>
            </summary>
            <param name="steps">[in] number of steps to advance the pointer (default = 1)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.SeekFirst">
            <summary>
                <para>Seek the first record</para>
                <para>note: must be called once before any Inc or Read</para>
                <para>Resets the pointer to the start</para>
            </summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AttachToCurrentThread">
            <summary>
                <para>Attach this object to the current thread</para>
                <para>This method can be used in case IFile was opened with allowMultiThreading = true
to improve performance when using the IGroupDataPointer object in current thread only.</para>
                <para>After calling the method, the object cannot be used in any other thread any longer
(except when calling AttachToCurrentThread again within the new thread!).</para>
                <para>see also IFileManager::OpenFile</para>
            </summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroup(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroup(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroup(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get channel group for given index</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@,System.Int64)" />, <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroupCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <param name="index">[in] index zero-based index of channel group in IGroupDataPointer</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IChannelGroup object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroupCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroupCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroupCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of channel groups added successfully to the IGroupDataPointer</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@,System.Int64)" />, <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.GetChannelGroup(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>number of channel groups (0 on error)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@,System.Int64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,System.Int64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@,System.Int64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IGroupDataPointer.AddChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@,System.Int64)">
            <summary>
                <para>Adds a channel group to the IGroupDataPointer</para>
                <para>Adds a channel group to the internal array of channel groups.</para>
                <para>note: Channel groups without signal data will be refused.</para>
                <para>The return value is the zero-based index of the channel group as to be used for other methods (e.g. GetRecordCount, GetTimeNs, ...).</para>
                <para>Adding a new channel group after reading has started requires a new call to SeekFirst!</para>
                <para>note: It is not allowed to add a channel group from a different file, nor to add it a second time. In addition, channel groups without any samples will be rejected (return value = eNoDataAvailable).</para>
            </summary>
            <param name="channelGroup">[in] channel group to be added. Note that the channel group will not be released before IGroupDataPointer::Release.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="timeOffsetNs">
                <para>[in] timeOffsetNs (default value = 0) a time offset in nanoseconds can be assigned for the channel group.</para>
                <para>The offset will be added to the time value of the channel group, e.g. to synchronize the time stamps for channel groups from different files.</para>
            </param>
            <returns>zero-based index of added channel group, or -1 on error</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IGroupDataPointer">
            <summary>
                <para>Access to signal data synchronized over several channel groups</para>
                <para>The IGroupDataPointer object gives access to signal data from several channel groups</para>
                <para>synchronized by a synchronization domain (currently only time).</para>
                <para>It can also be used to read interpolated values for equidistant time steps.</para>
                <para>A group data pointer can be created by IFile::CreateGroupDataPointer.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFormatInfo.GetProgramIdentifier">
            <summary>
                <para>Get program identifier</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFormatInfo.GetVersionString">
            <summary>
                <para>Get version string</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFormatInfo.GetVersionNumber">
            <summary>
                <para>Get MDF version number</para>
            </summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IFormatInfo">
            <summary>
                <para>Information about the file format and version</para>
                <para>The IFormatInfo object is the equivalent to the ID block of the MDF file.</para>
                <para>The ID block is defined both for MDF3 and MDF4 and contains the format information.</para>
                <para>You can read the MDF version number and string and the program identifier.</para>
                <para>note: for MDF4 more info about the creating tool can be found in ICreatorInfo object returned by IFile::GetCreatorInfo.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileSizeObserver.GetEstimatedFileSize">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileSizeObserver.GetEstimatedFileSize(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileSizeObserver.GetEstimatedFileSize(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Return the current estimated file size</para>
                <para>The file size on disk may not be the final file size because some data might still be contained in memory buffers (e.g. using IDataWriter or with AsyncFileWrite option).</para>
                <para>This method returns an estimated size of the file after flushing the buffers. When writing compressed data (MDF &gt;= 4.1), this may only be a rough guess.</para>
                <para>The method can be used in a polling mechanism to react if the final file size exceeds a certain limit (e.g. start a new output file).</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>current estimated file size, 0 on error or if file size estimation is not active (see pErrorCode)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileSizeObserver.GetFile">
            <summary>
                <para>Get reference to observed file</para>
            </summary>
            <returns>pointer to IFile object, null on error</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IFileSizeObserver">
            <summary>
                <para>Helper for observing the file size when writing an MDF file</para>
                <para>The IFileSizeObserver object allows to observe the size of an MDF file during writing.</para>
                <para>When writing sorted MF4 files or using option eUseAsyncFileWrite for IFileManager::CreateFile,
data is buffered and not written immediately to the file on the hard disk.</para>
                <para>In order to survey the size of the final MDF file, the IFileSizeObserver object helps.</para>
                <para>note: the estimated file size may differ from the final file size, especially when writing compressed data (MDF &gt;= 4.1)</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.RewriteFile(System.String,System.String,System.UInt32,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.RewriteFile(System.String,System.String,Vector.Mdf4LibDotNet.RewriteFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.RewriteFile(System.String,System.String,Vector.Mdf4LibDotNet.RewriteFileOptionFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.RewriteFile(System.String,System.String,Vector.Mdf4LibDotNet.RewriteFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.RewriteFile(System.String,System.String,Vector.Mdf4LibDotNet.RewriteFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
                <para>Re-writing of an MDF file</para>
                <para>note: the method can be used to defragment an MDF file, i.e. to close gaps (e.g. after IFile::DeleteAttachment()).</para>
            </summary>
            <param name="srcFilePath">[in] file path and name of the file to re-write</param>
            <param name="dstFilePath">[in] file path and name of the destination file to save the re-written file.
If not specified or equal to source file, then the source file will be replaced</param>
            <param name="flags">[in] bit combination of option flags, see ::RewriteFileOptionFlags (default: ::eRewriteFileOptionUnspecified)</param>
            <param name="progressCallback">[in] the validate operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface may be given which receives the progress feedback and which may
also be used to cancel the operation</param>
            <returns>error code of the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.ValidateFile(System.String,System.UInt32,Vector.Mdf4LibDotNet.IValidateFileCallback,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.ValidateFile(System.String,Vector.Mdf4LibDotNet.ValidateFileOptionFlags,Vector.Mdf4LibDotNet.IValidateFileCallback,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.ValidateFile(System.String,Vector.Mdf4LibDotNet.ValidateFileOptionFlags,Vector.Mdf4LibDotNet.IValidateFileCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.ValidateFile(System.String,Vector.Mdf4LibDotNet.ValidateFileOptionFlags,Vector.Mdf4LibDotNet.IValidateFileCallback,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.ValidateFile(System.String,Vector.Mdf4LibDotNet.ValidateFileOptionFlags,Vector.Mdf4LibDotNet.IValidateFileCallback,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
                <para>Validates an MDF file</para>
                <para>note: the method also can be used to only determine if the file is sorted without immediately sorting it.</para>
                <para>See ::eTestSortMode.</para>
            </summary>
            <param name="filePath">[in] file path and name of the file to validate</param>
            <param name="flags">[in] bit combination of option flags, see ValidateFileOptionFlags</param>
            <param name="validateFileCallback">[in] an IValidateFileCallback interface may be given to receive error
and (if activated) warning messages during the validation.
The messages are equal to the messages in error log of Vector MDF Validator.</param>
            <param name="progressCallback">[in] the validate operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface may be given which receives the progress feedback and which may
also be used to cancel the operation</param>
            <returns>error code of the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.FinalizeFile(System.String,System.String,System.UInt32,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.FinalizeFile(System.String,System.String,Vector.Mdf4LibDotNet.FinalizeFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.FinalizeFile(System.String,System.String,Vector.Mdf4LibDotNet.FinalizeFileOptionFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.FinalizeFile(System.String,System.String,Vector.Mdf4LibDotNet.FinalizeFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.FinalizeFile(System.String,System.String,Vector.Mdf4LibDotNet.FinalizeFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
                <para>Finalizes an unfinalized MDF file</para>
                <para>note: the method also can be used to only determine if the file is unfinalized without immediately finalizing it.</para>
                <para>See ::eTestFinalizationMode.</para>
            </summary>
            <param name="srcFilePath">[in] file path and name of the file to finalize</param>
            <param name="dstFilePath">[in] file path and name of the destination file to save the finalized file.
If not specified or equal to source file, then the source file will be replaced</param>
            <param name="flags">[in] bit combination of option flags, see ::FinalizeFileOptionFlags (default: ::eFinalizeFileOptionUnspecified)</param>
            <param name="progressCallback">[in] the finalize operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface may be given which receives the progress feedback and which may
also be used to cancel the operation.</param>
            <returns>error code of the operation, If the file was already finalized, error code ::eFileAlreadySorted will be returned and the file will NOT be copied to the destination file!</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.CreateFileOptionFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,System.Boolean,System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.CreateFile(System.String,System.UInt16,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CreateFileOptionFlags,System.Boolean,System.String)">
            <summary>
                <para>Creates a new file and opens it</para>
                <para>note: only available with extended licensing of MDF4 Lib ("write option").</para>
                <para>An opened file will be closed automatically when the IFile object and all child objects have been released</para>
                <para>note: If the file already exists, the function either fails or overwrites (deletes!) the file, depending on the setting of option bit eOverwriteExistingFile.</para>
            </summary>
            <param name="filePath">[in] file path and name of the file to create</param>
            <param name="mdfVersion">[in] version number of MDF format to use. Currently supported values: 200, 210, 300, 310, 320, 330, 400, 410.</param>
            <param name="errorCode">[out] returns the error code for the operation.</param>
            <param name="flags">[in] bit combination of option flags, see ::CreateFileOptionFlags. Default: eCreateFileOptionUnspecified</param>
            <param name="allowMultiThreading">
                <para>[in] allowMultiThreading if true, then the opened file (and its elements except IDataPointer) may be used in other threads than the current one.</para>
                <para>Default: true</para>
            </param>
            <param name="progId">
program identifier to set in MDF header (max 8 characters, string will be truncated if longer). Default: null.
            If null or empty, "MDF4Lib" will be used as program identifier.
            Note: the program identifier in MDF can only contain Basic Latin ASCII characters (i.e. 32 &lt;= ASCII code &lt;= 126, no extended ASCII codes).
            As a recommendation, the  program  identifier inserted into the 8 characters should be the base name (first eight characters) of the EXE/DLL of the writing application.
            Alternatively, also version information of the application can be appended (e.g. "MyApp45" for version 4.5 of MyApp.exe).
            For MDF4, detailed information about the generating application can be added in the first FileHistory block.
            Please use IFile::SetFileHistoryInfo() for this.
</param>
            <returns>on success the IFile interface of the created file, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetSerialNumber">
            <summary>
                <para>Request the serial number used for licensing</para>
                <para>note: the serial number must be given for first call to GetFileManager</para>
            </summary>
            <returns>serial number, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetCustomerName">
            <summary>
                <para>Request the customer name used for licensing</para>
                <para>note: the customer name must be given for first call to GetFileManager</para>
            </summary>
            <returns>customer name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetLicenseLevel">
            <summary>
                <para>Request the current license level</para>
                <para>note: the license level is determined by first call to GetFileManager from
specified customer information (customer name, serial number and registration key)</para>
            </summary>
            <returns>license level, see LicenseLevel</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.LogMessage(Vector.Mdf4LibDotNet.LogSinkLevel,System.String)">
            <summary>
                <para>Log a message to all registered global log sinks</para>
                <para>This method can be used to log own log message from client code</para>
                <para>note:</para>
                <para>Only log sinks previously registered by IFileManager::RegisterLogSink will receive the message.</para>
                <para>see ILogSink, IFileManager::RegisterLogSink</para>
            </summary>
            <param name="logLevel">[in] logging level for this message</param>
            <param name="message">[in] the message to write</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.UnregisterLogSink(Vector.Mdf4LibDotNet.ILogSink)">
            <summary>
                <para>Unregister a LogSink for debug logging</para>
                <para>Only log sinks previously registered can be unregistered.</para>
                <para>note:</para>
                <para>If a log sink has been registered several times, only the last inserted instance will be removed.</para>
                <para>see ILogSink, IFileManager::RegisterLogSink</para>
            </summary>
            <param name="logSink">[in] log sink to be unregistered</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.RegisterLogSink(Vector.Mdf4LibDotNet.ILogSink,Vector.Mdf4LibDotNet.LogSinkLevel)">
            <summary>
                <para>Register a LogSink for debug logging</para>
                <para>All registered log sinks will receive the debug log messages equal or higher to the specified
minimum logging level (default: Info, i.e. all messages are logged)</para>
                <para>A LogSink usually will write the messages to a debug log file, but may also write them to the GUI or some
other output.</para>
                <para>see ILogSink, IFileManager::UnregisterLogSink</para>
            </summary>
            <param name="logSink">[in] log sink to be registered</param>
            <param name="minimumLevel">
                <para>[in] minimum logging level of messages given to log sink. This can be used to restrict logging only to warnings or errors.</para>
                <para>Default: eInfo (i.e. all messages are logged)</para>
            </param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetMaxSupportedMdfVersion(System.Byte)">
            <summary>
                <para>Request the supported MDF version within the given major version</para>
            </summary>
            <param name="majorVersion">[in] major version number (e.g. 3 for MDF 3.x or 4 for MDF 4.x)</param>
            <returns>max supported MDF version number, e.g. 400 for MDF 4.0.0</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetInterfaceVersion(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
                <para>Request version of MDF4Lib interface</para>
                <para>note: The interface (API) of MDF4Lib has a 3 part version number which will be increased in case
the interface is changed.</para>
                <para>see CheckInterfaceCompatibility</para>
            </summary>
            <param name="majorVersion">[out] the major version number will be returned (e.g. 1 for interface version 1.0.2)</param>
            <param name="minorVersion">[out] the minor version number will be returned (e.g. 0 for MDF4Lib 1.0.1)</param>
            <param name="revision">[out] the revision number will be returned (e.g. 2 for MDF4Lib 1.0.2)</param>
            <returns>interface version number as string for display, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetLibraryVersion(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
                <para>Request version of MDF4Lib</para>
            </summary>
            <param name="majorVersion">[out] the major version number will be returned (e.g. 1 for MDF4Lib 1.0.2)</param>
            <param name="minorVersion">[out] the minor version number will be returned (e.g. 0 for MDF4Lib 1.0.2)</param>
            <param name="revision">[out] the revision number will be returned (e.g. 2 for MDF4Lib 1.0.2)</param>
            <returns>version number as string for display (including date and other info), null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,Vector.Mdf4LibDotNet.SortFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,Vector.Mdf4LibDotNet.SortFileOptionFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,Vector.Mdf4LibDotNet.SortFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,System.UInt32,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,Vector.Mdf4LibDotNet.SortFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.SortFile(System.String,System.String,Vector.Mdf4LibDotNet.SortFileOptionFlags,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
                <para>Sorts the specified MDF file</para>
                <para>note: the method also can be used to only determine if the file is sorted without immediately sorting it.</para>
                <para>See eTestSortMode.</para>
                <para>If the file already was sorted, error code eFileAlreadySorted will be returned and the file will NOT be copied to the destination file!</para>
            </summary>
            <param name="srcFilePath">[in] file path and name of the file to sort</param>
            <param name="dstFilePath">
                <para>[in] file path and name of the destination file to save the sorted file.</para>
                <para>If not specified or equal to source file, then the source file will be replaced</para>
            </param>
            <param name="flags">[in] options bit combination of option flags, see SortFileOptionFlags. Default: eSortFileOptionUnspecified</param>
            <param name="progressCallback">[in] the sort operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface pointer may be given which receives the progress feedback and which may also be used to cancel the operation. Default: null</param>
            <returns>error code of the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.OpenFileMode,System.Boolean)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.OpenFileMode)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.OpenFileMode,System.Boolean)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.OpenFileMode,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.OpenFileMode,System.Boolean)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.OpenFile(System.String,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.OpenFileMode,System.Boolean)">
            <summary>
                <para>Opens the specified file</para>
                <para>An opened file will be closed automatically when the IFile object and all child objects have been released.</para>
                <para>note:</para>
                <para>If the file already is open and has been opened with equal flags,
the method simply returns the IFile interface of the already open file
and errorCode will indicate that the file already was open (eFileAlreadyOpen)</para>
                <para>In this case, the reference counter of the file will be incremented</para>
                <para>note: when opening the file with a mode that locks the file for reading by others, performance for file operations will decrease!</para>
            </summary>
            <param name="filePath">[in] filePath file path and name of the file to open</param>
            <param name="errorCode">[out] returns the error code for the operation.</param>
            <param name="mode">
                <para>[in] mode mode for opening the file (read/write access, sharing). Default: eReadShare.</para>
                <para>Note: eReadWriteExclusive allows to modify (extend) existing MDF files. This is only available with extended licensing of MDF4 Lib ("write option").</para>
            </param>
            <param name="allowMultiThreading">
                <para>[in] allowMultiThreading if true, then the opened file (and its elements except IDataPointer and IDataWriter) may be used in other threads than the current one.</para>
                <para>Default: true</para>
            </param>
            <returns>on success the IFile interface of the opened file, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFileManager.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IFileManager">
            <summary>
                <para>File manager for opening a file</para>
                <para>The file manager is the root for opening MDF files with MDF4Lib.</para>
                <para>It also returns general information about MDF4Lib and allows to register
so - called log sinks for creating debug log output.</para>
                <para>see ILogSink and IFileManager::RegisterLogSink</para>
                <para>The file manager will be returned by the VMdf4Lib class.</para>
            </summary>
            <example>Find below an example how to get the IFileManager interface.
<code>
using Vector.Mdf4LibDotNet;
using (VMdf4Lib mdf4Lib = new VMdf4Lib())
{
   bool bResult = mdf4Lib.Init(customerName, serialNumber, regKey, assertCallback, true, true);
   if (bResult)
   {
     using (IFileManager fileManager = mdf4Lib.GetFileManager())
     {
     }
  }
}
</code></example>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFirstAndLastTimeStampNs(System.Int64@,System.Int64@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFirstAndLastTimeStampNs(System.Int64@,System.Int64@,System.UInt64@,System.UInt64@,Vector.Mdf4LibDotNet.IChannelGroup[])" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFirstAndLastTimeStampNs(System.Int64@,System.Int64@,System.UInt64@,System.UInt64@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFirstAndLastTimeStampNs(System.Int64@,System.Int64@,System.UInt64@,System.UInt64@,Vector.Mdf4LibDotNet.IChannelGroup[])" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFirstAndLastTimeStampNs(System.Int64@,System.Int64@,System.UInt64@,System.UInt64@,Vector.Mdf4LibDotNet.IChannelGroup[])">
            <summary>
                <para>Search the first and/or last (relative) time stamp of all channel groups in ns</para>
                <para>Note: in addition or instead of the time stamp itself, the index of the respective channel group can be retrieved. See GetChannelGroup.</para>
                <para>Hint: in order to convert the relatie time to an absolute time, get ITimeStamp with GetStartTime and use ITimeStamp::GetTimeStringForRelativeTimeNs or ITimeStamp::GetTimePartsForRelativeTimeNs</para>
            </summary>
            <param name="firstNs">[out] the first (lowest) relative time stamp in ns will be returned for all channel groups in the file which are not contained in the exclude list.</param>
            <param name="lastNs">[out] the last (highest) relative time stamp in ns will be returned for all channel groups in the file which are not contained in the exclude list.</param>
            <param name="cgIndexFirst">[out] the index of the channel group that contains the first (lowest) relative time stamp will be returned for all channel groups in the file which are not contained in the exclude list.
            <br />In case several channel groups contain the same first (lowest) time stamp, the group with the lowest index will be returned.</param>
            <param name="cgIndexLast">[out] the index of the channel group that contains the last (highest) relative time stamp will be returned for all channel groups in the file which are not contained in the exclude list.
            <br />In case several channel groups contain the same last (highest) time stamp, the group with the lowest index will be returned.</param>
            <param name="excludeList">[in] if specified: list of IChannelGroup objects which should be excluded for the search (exclude list).
            <br />Note: all channel group objects must be in the same file</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a group data pointer</para>
                <para>note: A group data pointer synchronizes several channel groups by the given synchronization domain (default: time).</para>
                <para>note: the extended method IFile::CreateDataPointerEx allows to specifiy options for the created IGroupDataPointer</para>
                <para>see: IGroupDataPointer</para>
            </summary>
            <param name="flags">[in] bit combination of option flags, see DataPointerOptionsFlags. Default: eUseReadBuffer
                    <br /><br />Currently, only the following flags are allowed: ::eUseReadBuffer, ::eDisableStatusTabWarning, ::eDisableVerbalTableError</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>IGroupDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetCommentTextAndFields(System.String,System.String,System.String,System.String,System.String,Vector.Mdf4LibDotNet.FieldProperties[])">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.SetCommentTextAndFields(System.String,System.String,System.String,System.String,System.String,Vector.Mdf4LibDotNet.FieldProperties[],Vector.Mdf4LibDotNet.CommentMergeFlags)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetCommentTextAndFields(System.String,System.String,System.String,System.String,System.String,Vector.Mdf4LibDotNet.FieldProperties[],Vector.Mdf4LibDotNet.CommentMergeFlags)">
            <summary>
Set comment text and comment fields of file
<para>Note: only available for newly created or writable file. The previous comment will be be replaced (like for <see cref="M:Vector.Mdf4LibDotNet.IFile.SetComment(Vector.Mdf4LibDotNet.IComment)" />.</para></summary>
            <param name="comment"> string with plain comment text, can be null (see options). See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetPlainCommentText(Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="author"> string with text for author, can be null (see options). See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAuthor(Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="department"> string with text for department, can be null (see options). See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetDepartment(Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="project"> string with text for project, can be null (see options). See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetProject(Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="subject"> string with text for subject, can be null (see options). See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetSubject(Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="additionalCommentFields"> array with additional comment fields and their properties, can be null or empty. See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldProperties(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" />.</param>
            <param name="options"> bit flags for merging existing information with new information, see ::CommentMergeFlags.
           Attributes in MDF4 are only replaced for an already existing additional field
           if the attribute value is not null (for unit, desc, lang) or ::eFieldDataTypeUnspec (for type).
           For standard fields: if the string pointer for a standard field is null (e.g. author = null) and
           <ul><li>if ::eMergeCommentFields flag is set, the respective standard field will not be changed. </li><li>if ::eMergeCommentFields flag is not set, the respective standard field will be removed (or set to empty text for MDF 3.x)</li></ul></param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldProperties(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldProperties(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldProperties(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get properties (including name and value) of additional comment field for given index
</summary>
            <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldCount" />
            <param name="index"> index of additional comment field, see <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>structure with properties, see FieldProperties. In case of error, name is null.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStandardCommentFieldProperties(Vector.Mdf4LibDotNet.StandardFieldType)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetStandardCommentFieldProperties(Vector.Mdf4LibDotNet.StandardFieldType,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStandardCommentFieldProperties(Vector.Mdf4LibDotNet.StandardFieldType,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get properties (including name and value) of a standard comment field
</summary>
            <para>See <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAuthor(Vector.Mdf4LibDotNet.ErrorCode@)" />, <see cref="M:Vector.Mdf4LibDotNet.IFile.GetDepartment(Vector.Mdf4LibDotNet.ErrorCode@)" />, <see cref="M:Vector.Mdf4LibDotNet.IFile.GetProject(Vector.Mdf4LibDotNet.ErrorCode@)" />, <see cref="M:Vector.Mdf4LibDotNet.IFile.GetSubject(Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            <param name="type"> specifies the standard field for reading the properties, see StandardFieldType </param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>structure with properties, see FieldProperties. In case of error, name is null.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.Close">
            <summary>
                <para>Close the file handle for the file</para>
                <para>Note: After calling this method, no read or write operations (also for contained objects) will be possible any longer!</para>
                <para>For a file opened with write access, the file will be flushed before closing it, also the IDataWriter objects.</para>
                <para>Close will be called internally when the IFile object is released, so an explicit call to Close may only be necessary
when not all MDF4 Lib objects for this IFile object are released yet (for instance when using .NET interfaces and Dispose is
not called for each MDF4 Lib object).</para>
            </summary>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEvent(Vector.Mdf4LibDotNet.EventType,Vector.Mdf4LibDotNet.EventCause,System.String,System.Int64,System.Double,Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEvent(Vector.Mdf4LibDotNet.EventType,Vector.Mdf4LibDotNet.EventCause,System.String,System.Int64,System.Double,Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create a new event in this file

Note: only available for newly created or writable file.
Note: not yet available for MDF3

The new event will be appended to the event list of this file.
By default, the new event has a global scope, i.e. applies to all channels in the file.
</summary>
            <param name="type">[in] type of the event, see EventType. For MDF3, only event type eTrigger is possible.</param>
            <param name="cause">[in] cause of the event, see EventCause. Will be ignored for MDF3.</param>
            <param name="name">[in] name of the event, can be null if there is no name. Will be ignored for MDF3.</param>
            <param name="syncBase">[in] base for sync value. The sync value is calculated by multiplication of syncBase with syncFactor and has a unit according to syncType.
The sync value is when the event occurred (relative to start sync value of file). Typically time is used for synchronization.
For example, the raw value of the time channel (e.g. nanoseconds) can be used as syncBase whereas syncFactor is used to convert it to seconds.
This allows a higher precision than only using double values. See also IEvent::GetSyncBaseValue() and IEvent::GetSyncFactor().</param>
            <param name="syncFactor">[in] factor for sync value. syncFactor must not be zero, except if syncBase is one (e.g. to time value in seconds as REAL value). See also above.</param>
            <param name="syncType">[in] type of synchronization with other events and master channels of channel groups, see <see cref="T:Vector.Mdf4LibDotNet.SyncType" />.
Only values eTimeSync, eAngleSync and eDistanceSync are allowed.
Index-based events (sync type eIndexSync) must be created for a channel group or channel scope.</param>
            <param name="comment">[in] IComment object to set for the event.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (ev_comment.XSD).</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns> on success the IEvent interface of the created event, otherwise null.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEvent(Vector.Mdf4LibDotNet.EventType,Vector.Mdf4LibDotNet.EventCause,System.String,System.Double,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEvent(Vector.Mdf4LibDotNet.EventType,Vector.Mdf4LibDotNet.EventCause,System.String,System.Double,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create a new event in this file

Note: only available for newly created or writable file.
Note: not yet available for MDF3

The new event will be appended to the event list of this file.
By default, the new event has a global scope, i.e. applies to all channels in the file. This can be changed by IEvent::SetScope().
</summary>
            <param name="type">[in] type of the event, see ::EventTypeEnum. For MDF3, only event type ::eTrigger is possible.</param>
            <param name="cause">[in] cause of the event, see EventCause. Will be ignored for MDF3.</param>
            <param name="name">[in] name of the event, can be null if there is no name. Will be ignored for MDF3.</param>
            <param name="timeInSeconds">[in] time in seconds when the event occurred (relative to start time of file)
Note: an overloaded version of CreateEvent allows to specify baseSync and syncFactor.</param>
            <param name="comment">[in] IComment object to set for the event.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (ev_comment.XSD).</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns> on success the IEvent interface of the created event, otherwise null.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetEventSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get event set for events in file.
Note: The resulting IEventSet object offers further filtering of the events.
</summary>
            <param name="filterFlags">[in] flags for filtering, value is a bit combination of EventFilterFlags</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns> pointer to IEventSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.LogMessage(Vector.Mdf4LibDotNet.LogSinkLevel,System.String)">
            <summary>
                <para>Log a message to all log sinks registered for this file</para>
                <para>This method can be used to log own log message from client code</para>
                <para>note:</para>
                <para>Only log sinks previously registered by IFile::RegisterLogSink will receive the message.</para>
                <para>see ILogSink, IFile::RegisterLogSink</para>
            </summary>
            <param name="logLevel">[in] logging level for this message</param>
            <param name="message">[in] the message to write</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.UnregisterLogSink(Vector.Mdf4LibDotNet.ILogSink)">
            <summary>
                <para>Unregister a LogSink for debug logging</para>
                <para>Only log sinks previously registered can be unregistered.</para>
                <para>note:</para>
                <para>If a log sink has been registered several times, only the last inserted instance will be removed.</para>
                <para>see ILogSink, IFile::RegisterLogSink</para>
            </summary>
            <param name="logSink">[in] log sink to be unregistered</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.RegisterLogSink(Vector.Mdf4LibDotNet.ILogSink,Vector.Mdf4LibDotNet.LogSinkLevel)">
            <summary>
                <para>Register a LogSink for debug logging</para>
                <para>All registered log sinks will receive the debug log messages equal or higher to the specified
minimum logging level (default: Info, i.e. all messages are logged)</para>
                <para>A LogSink usually will write the messages to a debug log file, but may also write them to the GUI or some
other output.</para>
                <para>see ILogSink, IFile::UnregisterLogSink</para>
            </summary>
            <param name="logSink">[in] log sink to be registered</param>
            <param name="minimumLevel">
                <para>[in] minimum logging level of messages given to log sink. This can be used to restrict logging only to warnings or errors.</para>
                <para>Default: eInfo (i.e. all messages are logged)</para>
            </param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.DeleteAttachment(System.UInt64,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.DeleteAttachment(System.UInt64,Vector.Mdf4LibDotNet.DeleteAttachmentFlags)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.DeleteAttachment(System.UInt64,Vector.Mdf4LibDotNet.DeleteAttachmentFlags)">
            <summary>
                <para>Delete an attachment from global list of attachments</para>
                <para>see: GetAttachmentCount</para>
                <para>note: the attachment can only be deleted if currently no IAttachment object exists for it.</para>
                <para>This method does not support future MDF versions.</para>
                <para>It only deletes the attachment references, but does not decrease the file size.</para>
            </summary>
            <param name="index">[in] index of attachment</param>
            <param name="flags">[in] bit combination of option flags, see DeleteAttachmentFlags</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetLimit(Vector.Mdf4LibDotNet.LimitType,System.Int32)">
            <summary>
                <para>Set a limit for a specific limit type</para>
            </summary>
            <param name="type">[in] type of limit to be set. See LimitType for details.</param>
            <param name="limitSize">[in] size of limit in Bytes. If 0 no limit will be used, if &lt; 0 then the default value for the respective limit type will be used.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileSizeObserver">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFileSizeObserver(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileSizeObserver(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get access to IFileSizeObserver object</para>
                <para>note: only available for newly created or writable file, not available while an IDataWriter object exists.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IFileSizeObserver object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetBusEventType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetBusEventType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetBusEventType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the type of bus events contained in the file</para>
                <para>note: for MDF version &gt;= 4.1 only flags of the channel groups are checked, for earlier versions this is not supported yet.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>type of the contained bus events see BusEventType, or eBusEventUnspec in case of an error or if not supported.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.ContainsBusEvent">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.ContainsBusEvent(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.ContainsBusEvent(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Check if there is any channel group that contains a bus event (bus logging for MDF 4.1)</para>
                <para>note: for MDF version &gt;= 4.1 only a flag of the channel group is checked, for earlier versions this is not supported</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>true if there is at least one channel group that contains a bus event, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetFileHistoryInfo(System.String,System.String,System.String,System.String,System.String)">
            <summary>
                <para>For a newly created or changed file, information about the writing application can be written to the file history (latest ICreatorInfo)</para>
                <para>This information will be written to the file history entry created for the new/changed file.</para>
                <para>If this function is not called, the fields of the file history entry are filled with the default information specified below for each argument.</para>
                <para>note: not available for MDF3, only available for newly created or writable file.</para>
            </summary>
            <param name="appName">[in] string with name of the writing application. If null or empty, the base name of the MDF4 Lib DLL will be used, e.g. "MDF4Lib".</param>
            <param name="appVersion">[in] version string of the writing application in the format A.B or A.B.C or A.B.C.D. If null or empty or no appName specified, the version number of the MDF4 Lib will be used.</param>
            <param name="vendorName">[in] vendor name of the writing application. If null or empty or no appName specified, the vendor name of the MDF4 Lib will be used.</param>
            <param name="userName">[in] user name. If null or empty, the Windows login name will be used.</param>
            <param name="comment">[in] main comment text for file history entry. If null or empty, a default text created by MDF4 Lib is used.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateEmbeddedAttachment(System.Byte[],System.String,Vector.Mdf4LibDotNet.IComment,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create an embedded attachment from a buffer</para>
                <para>note: only available for newly created or writable file.</para>
                <para>note: for MDF3, only a single attachment is possible and compressed attachments are not supported (error code will be set to eNotAvailable)</para>
            </summary>
            <param name="buffer">[in] buffer containing the data to attach</param>
            <param name="mimeType">[in] MIME type string of the attachment.</param>
            <param name="comment">[in] comment to add to the attachment. Default: null
<para>This can be a plain text or an XML fragment containing additional meta data.</para><para>In case of an XML fragment it should be valid XML and match the schema at_comment.xsd for the respective MDF version of the file.</para></param>
            <param name="compressionLevel">[in] level of compression: 0 = none, 1 = best speed, ..., 9 = best compression, -1 = default compression level). Must be 0 for MDF3.</param>
            <param name="calculateMD5">[in] if true, an MD5 check sum will be calculated for the attachment. Default: false</param>
            <param name="progressCallback">[in] the operation may take some time, e.g. when calculating the MD4 check sum or when embedding the attachment.
<para>For feedback (e.g. progress bar), a IProgressCallback interface pointer may be given which receives the progress feedback and which may
also be used to cancel the operation. Default: null</para></param>
            <param name="errorCode">[out] returns the error code for the operation.</param>
            <returns>on success the IAttachment interface of the created attachment, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateAttachment(System.String,System.String,Vector.Mdf4LibDotNet.IComment,System.Boolean,System.Int32,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateAttachment(System.String,System.String,Vector.Mdf4LibDotNet.IComment,System.Boolean,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateAttachment(System.String,System.String,Vector.Mdf4LibDotNet.IComment,System.Boolean,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateAttachment(System.String,System.String,Vector.Mdf4LibDotNet.IComment,System.Boolean,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateAttachment(System.String,System.String,Vector.Mdf4LibDotNet.IComment,System.Boolean,System.Int32,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create an attachment</para>
                <para>note: only available for newly created or writable file.</para>
                <para>note: for MDF3, only a single attachment is possible and external or compressed attachments are not supported</para>
            </summary>
            <param name="filePath">
                <para>[in] name and path of the file to be attached</para>
                <para>Note: if no path or a relative path is specified, the folder of the MDF file is used as root folder.</para>
                <para>For MDF4, the file name will be saved:</para>
                <para>for embedded attachments, only the file name will be saved without path information.</para>
                <para>for external attachments, the path as specified will be saved, which may be the file path relative to the MDF file or an absolute path.</para>
            </param>
            <param name="mimeType">[in] MIME type string of the attachment.</param>
            <param name="comment">[in] comment to add to the attachment. Default: null
<para>This can be a plain text or an XML fragment containing additional meta data.</para><para>In case of an XML fragment it should be valid XML and match the schema at_comment.xsd for the respective MDF version of the file.</para></param>
            <param name="embedded">[in] if true, an embedded attachment will be created, otherwise an external, see ::AttachmentTypeEnum. Must be true for MDF3. Default: false</param>
            <param name="compressionLevel">[in] level of compression for embedded attachment (0 = none, 1 = best speed, ..., 9 = best compression, -1 = default compression level). Must be 0 for MDF3. Default: 0</param>
            <param name="calculateMD5">[in] if true, an MD5 check sum will be calculated for the attachment (MDF4 only). Default: false</param>
            <param name="progressCallback">[in] the operation may take some time, e.g. when calculating the MD4 check sum or when embedding the attachment.
<para>For feedback (e.g. progress bar), a IProgressCallback interface pointer may be given which receives the progress feedback and which may
also be used to cancel the operation. Default: null</para></param>
            <param name="errorCode">[out] returns the error code for the operation. Default: null</param>
            <returns>on success the IAttachment interface of the created attachment, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateChannelGroup(System.String,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateChannelGroup(System.String,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateChannelGroup(System.String,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a new channel group in this file</para>
                <para>The new channel group will be appended to the channel group list of this file.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="acquisitionName">[in] acquisition name of channel group.</param>
            <param name="acquisitionSource">[in] pointer to ISourceInfo object to set as acquisition source for the channel group.
<para>Note: object must be in same file.</para></param>
            <param name="comment">[in] comment object of type IComment to set for the channel.
<para>Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cg_comment.XSD).</para></param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>on success the IChannelGroup interface of the created channel group, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetStartDistance(System.Double,System.Boolean)">
            <summary>
                <para>Set start distance of file</para>
                <para>note: start distance is optional and not available for MDF3.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="startDistance">[in] start distance in meters</param>
            <param name="isValid">[in] true if start distance is valid, otherwise false (for newly created file, start distance will be invalid by default)</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetStartAngle(System.Double,System.Boolean)">
            <summary>
                <para>Set start angle of file</para>
                <para>note: start angle is optional and not available for MDF3.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="startAngle">[in] start angle in radiants</param>
            <param name="isValid">[in] true if start angle is valid, otherwise false (for newly created file, start angle will be invalid by default)</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetStartTime(System.UInt64,Vector.Mdf4LibDotNet.TimeStampType,System.Int32,System.Int32)">
            <summary>
                <para>Change start time stamp of the file</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="timeStampNs">[in] elapsed nanoseconds since midnight (00:00:00), January 1, 1970. This does not include any daylight saving time offset.</param>
            <param name="timeStampType">[in] determines type of time stamp (local or UTC time). Also determines if the offsets for time zone and daylight saving time are valid.</param>
            <param name="timeZoneOffsetMin">[in] time zone offsets in minutes with respect to UTC time. Only valid if eUtcTimeWithOffsets or eLocalTimeWithOffsets is specified.</param>
            <param name="daylightSavingTimeOffsetMin">[in] daylight saving time offset in minutes. Only valid if eUtcTimeWithOffsets or eLocalTimeWithOffsets is specified.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetStartTime(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.TimeStampType,System.Int32,System.Int32)">
            <summary>
                <para>Change start time stamp of the file</para>
                <para>note: only available for newly created or writable file.</para>
                <para>When eLocalTime is specified, the user input has to INCLUDE the daylight saving time offset.</para>
            </summary>
            <param name="year">[in] year in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="month">[in] month in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="day">[in] day in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="hour">[in] hour in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="minute">[in] minute in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="second">[in] second in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="ns">[in] ns in human readable form. Must include daylight saving time offset if it represents a local time.</param>
            <param name="timeStampType">[in] determines type of time stamp (local or UTC time). Also determines if the offsets for time zone and daylight saving time are valid.</param>
            <param name="timeZoneOffsetMin">[in] time zone offsets in minutes with respect to UTC time. Only valid if eUtcTimeWithOffsets or eLocalTimeWithOffsets is specified.</param>
            <param name="daylightSavingTimeOffsetMin">[in] daylight saving time offset in minutes. Only valid if eUtcTimeWithOffsets or eLocalTimeWithOffsets is specified.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetStartTime(Vector.Mdf4LibDotNet.ITimeStamp,System.Int64)">
            <summary>
                <para>Change start time stamp of the file</para>
                <para>note: only available for newly created or writable file.</para>
                <para>For a newly created files the start time stamp automatically was set to the current system date/time</para>
            </summary>
            <param name="startTime">[in] start time to set, null to set to current system time.</param>
            <param name="offsetNs">[in] offset in nanoseconds to add to the given or created time stamp</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of file</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="comment">[in] object of type IComment, null to remove reference to comment object.
<para>Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</para></param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFactory">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFactory(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFactory(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get access to factory for creating sharable MDF objects (IComment, IUnit, IConversion and ISourceInfo)</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IFactory object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFilePath">
            <summary>
                <para>Get file path</para>
            </summary>
            <returns>full path name of the file</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointer">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.CreateGroupDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a group data pointer</para>
                <para>note: A group data pointer synchronizes several channel groups by the given synchronization domain (default: time).</para>
                <para>note: the extended method IFile::CreateDataPointerEx allows to specifiy options for the created IGroupDataPointer</para>
                <para>see: IGroupDataPointer</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>IGroupDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLog(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLog(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLog(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get file history entry for given index</para>
                <para>note: only available for MDF4</para>
                <para>see: GetFileHistoryLogCount GetCreatorInfo</para>
            </summary>
            <param name="index">[in] index of file history entry. For index 0, the same entry as for GetCreatorInfo</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to ICreatorInfo object, null on error or if none available (MDF3)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLogCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLogCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileHistoryLogCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of file history entries (FH block)</para>
                <para>note: only available for MDF4</para>
                <para>see: GetFileHistoryLog GetCreatorInfo</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of file history entries (0 for MDF3 or on error)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAttachment(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get attachment for given index</para>
                <para>note: for MDF3, a PR block is treated as attachment. There can be at most one PR block per MDF3 file.</para>
                <para>see: GetAttachmentCount</para>
            </summary>
            <param name="index">[in] index of attachment.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IAttachment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAttachmentCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of attachments</para>
                <para>note: for MDF3, a PR block is treated as attachment. There can be at most one PR block per MDF3 file.</para>
                <para>see: GetAttachment</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of attachments (0 on error or if not available, e.g. for MDF3)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroup(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroup(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroup(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get channel group for given index</para>
                <para>see: GetChannelGroupCount</para>
                <para>note: for unsorted MDF4, VLSD channel groups will not be considered</para>
            </summary>
            <param name="index">[in] index of channel group</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannelGroup object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroupCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroupCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelGroupCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of channel groups</para>
                <para>see: GetChannelGroup</para>
                <para>note: for unsorted MDF4, VLSD channel groups will not be considered</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of channel groups (0 on error)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get channel set for channels in file</para>
            </summary>
            <param name="filterFlags">[in] flags for filtering, value is a bit combination of ChannelFilterFlags</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannelSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartDistance">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetStartDistance(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartDistance(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get start distance</para>
                <para>note: start distance is optional and not available for MDF3</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>start distance in meters (0 on error or if not available)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartAngle">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetStartAngle(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartAngle(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get start angle</para>
                <para>note: start angle is optional and not available for MDF3</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>start angle in radiants (0 on error or if not available)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartTime">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetStartTime(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetStartTime(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get new reference to start time stamp object of the file</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>interface pointer for ITimeStamp object</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetCreatorInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get info about creator of the file</para>
                <para>note: only available for MDF4, for MDF3 please check IFormatInfo::GetProgramIdentifier</para>
                <para>see: GetFormatInfo GetFileHistoryLog</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to ICreatorInfo object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldValue(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldValue(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldValue(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get value of additional comment field for given index</para>
                <para>see: GetAdditionalCommentFieldCount</para>
            </summary>
            <param name="index">[in] index of additional comment field</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with value of additional comment field, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldName(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldName(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldName(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get name of additional comment field for given index</para>
                <para>see: GetAdditionalCommentFieldCount</para>
            </summary>
            <param name="index">[in] index of additional comment field</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with name of additional comment field, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAdditionalCommentFieldCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of custom fields for file comment</para>
                <para>note: in addition to the four standard fields (author, department, project, subject),
there can be additional fields for the file comment.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of additional comment fields, 0 on error or if no additional fields (check pErrorCode)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetSubject">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetSubject(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetSubject(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get subject as specified in file header</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with subject name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetProject">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetProject(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetProject(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get project as specified in file header</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with project name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetDepartment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetDepartment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetDepartment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get department as specified in file header</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with department name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAuthor">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetAuthor(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetAuthor(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get author as specified in file header</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with name of author, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetPlainCommentText">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetPlainCommentText(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetPlainCommentText(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get plain comment text</para>
                <para>note: for MDF3, some CANape encodes custom file comment fields into the comment text:</para>
                <para>use this method to get the comment text without the encoded fields</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with plain comment text, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get comment of file</para>
                <para>note: for MDF4 this can be XML (MD block) or plain text (TX block), for MDF3 it can only be plain text</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.IsSorted">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.IsSorted(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.IsSorted(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Check if file is sorted, i.e. all groups are sorted</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>true if file is sorted, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.HasWriteAccess">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.HasWriteAccess(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.HasWriteAccess(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Check if file has been opened with write access</para>
                <para>note: this method only checks the mode used for IFile::Open, it does not check if a file is write protected on disc or not!</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>true if file has successfully been opened with write access, false otherwise</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFormatInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFile.GetFormatInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFormatInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get new reference to format info object of the file</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>interface pointer for IFormatInfo object</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFile.GetFileName">
            <summary>
                <para>Get file name</para>
            </summary>
            <returns>name of the file without path</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IFile">
            <summary>
                <para>Represents an open MDF file</para>
                <para>The IFile object represents an open MDF file. It gives access to the file information and its contents.</para>
                <para>An MDF file usually contains one or more channel groups which build the tree hierarchy for the channels.</para>
                <para>The IFile also allows to access the channels directly by using IFile::GetChannelSet which allows to collect the channels
of all channel groups into a set.</para>
                <para>A file also can contain attachments, events and (MDF4 only) information about a channel hierarchy and a file history.</para>
                <para>An MDF file can be sorted for faster (index-based) access to the signal data. A file is sorted if all of its (data) groups are sorted.
Even if the file is not sorted, it is still possible to access all information. There may be sorted channel groups in an unsorted file,
e.g. if the file is only considered unsorted due to an array channel using CG template (MDF4 feature, currently not supported).</para>
                <para>Like for the IFileManager, for a IFile also log sinks can be registered to receive debug information. This is useful
to filter log entries for a specific file, e.g. to use a log sink for error messages for IFileManager, but to get more details for a
specific file.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[])">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.Byte[],System.UInt32,System.Byte[],System.Byte[])" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.Byte[])">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.Byte[],System.UInt32,System.Byte[],System.Byte[])" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.UInt32,System.Byte[])">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.Byte[],System.UInt32,System.Byte[],System.Byte[])" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePartsOfRecord(System.UInt32,System.Byte[],System.Byte[],System.UInt32,System.Byte[],System.Byte[])">
            <summary>
                <para>Write parts of a record.</para>
                <para>note: this method can be used to write the parts of the record not containing the reference to a VLSD channel or to write multiple values in one go, e.g. for arrays.
For optimized performance the record data (and possibly invalidation) Bytes may be assembled in the calling application and written directly.
<br />Any previously set time stamps or values and invalidation bits in the record can be overwritten.
<br />Depending on the configured FlushCheckMode (see SetFlushCheckMode), the method may detect this and return ::eNoFlushSinceLastValue, but the record will be written nevertheless!
<br />Depending on the configured TimeCheckMode (see SetTimeCheckMode), the method may detect reverse time stamps and return ::eReverseTimeStamp, but the record will be written nevertheless!
<br />Some flush and time check modes will not work with this method</para>
                <para>note: this method cannot be used with write mode ::eAutoFlush (see SetWriteMode).</para>
                <para>note: min/max value statistics for the individual channels are not updated when using this method.</para>
            </summary>
            <param name="offsetDataBytes">[in] offset from start of data bytes for writing the bytes given in dataBytes.</param>
            <param name="dataBytes">[in] buffer for the data bytes to write. Length of the buffer determines the number of bytes to write.
            <br />Note: offsetDataBytes + dataBytes.Length must not exceed the number of data bytes (see IChannelGroup::GetDataByteCount).</param>
            <param name="maskDataBytes">[in] if not specified or null, all bytes in dataBytes are written unchanged.
            <br />If maskDataBytes is specified, each byte in maskDataBytes will be used as mask for the respective byte in dataBytes: only bits set in the mask will be changed in the record.
            <br />For example, a mask with value 0 (no bit set) will leave the respective byte unchanged in the record, whereas a mask with value 0x0F changes the lower 4 bits and leaves the upper 4 bits unchanged.
            <br />The masks can be used to exclude bytes used by a VLSD channel, or to write bit channels or interleaving arrays.
</param>
            <param name="offsetInvalBytes">[in] offset from start of invalidation bytes for writing the bytes given in invalBytes.</param>
            <param name="invalBytes">[in] buffer for the invalidation Bytes to write (optional, MDF4 only). If null or not specified, none of the invalidation bits will be changed.
            <br />Note: offsetInvalBytes + invalByteCount must not exceed the number of invalidation bytes (see IChannelGroup::GetInvalByteCount).</param>
            <param name="maskInvalBytes">[in] if not specified or null, all bytes in invalBytes are written unchanged.
            <br />If maskInvalBytes is specified, each byte in maskInvalBytes will be used as mask for the respective byte in invalBytes: only bits set in the mask will be changed in the record.
            <br />For example, a mask with value 0 (no bit set) will leave the respective byte unchanged in the record, whereas a mask with value 0x0F changes the lower 4 bits and leaves the upper 4 bits unchanged.
            <br />The mask can be used to leave invalidation bits of channels not contained in the data bytes unchanged.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.SetFlushCheckMode(Vector.Mdf4LibDotNet.FlushCheckMode)">
            <summary>
Change the flush check mode
<para>note: the flush check mode influences performance and return values of Flush/Write methods</para>
The initial flush check mode can be changed via config file. By default it is eFlushCheckDisabled.
</summary>
            <param name="mode"> mode flush check mode to set, see FlushCheckMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.GetFlushCheckMode">
            <summary>
Get the currently active flush check mode
<para>see: SetFlushCheckMode</para><para>note: the default flush check mode may be changed by configuration file</para></summary>
            <returns>current flush check mode, see FlushCheckMode</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.SetTimeCheckMode(Vector.Mdf4LibDotNet.TimeCheckMode)">
            <summary>
Change the time check mode
<para>note: the time check mode influences performance and return values of Flush/Write methods</para>
The initial time check mode can be changed via config file. By default it is eTimeCheckDisabled.
</summary>
            <param name="mode"> mode time check mode to set, see TimeCheckMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.GetTimeCheckMode">
            <summary>
Get the currently active time check mode
<para>see: SetTimeCheckMode</para><para>note: the default time check mode may be changed by configuration file</para></summary>
            <returns>current time check mode, see TimeCheckMode</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePhysValue(Vector.Mdf4LibDotNet.IChannel,System.String,System.Boolean)">
            <summary>
Write the physical value (given as string) for the given channel

<para>note:</para><para>Only possible if conversion returns a string or 1:1 conversion for string data types.</para><para>The written string will be transformed from the Unicode or MBCS input string, depending on the library.</para><para>The written string always will be zero terminated. In case it is too long, it will be truncated.</para></summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[in] string value to write (must not be null)</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WritePhysValue(Vector.Mdf4LibDotNet.IChannel,System.Double,System.Boolean)">
            <summary>
Write the physical value (given as double value) for the given channel
<para>note: in case there is no conversion rule, the value will be written as raw value (1:1 conversion).</para>
If there is a conversion rule of other type than eLinear, an inverse conversion must be specified!
</summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[in] value to write</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WriteRawValue(Vector.Mdf4LibDotNet.IChannel,System.String,System.Boolean)">
            <summary>
Write the raw value (given as string) for the given channel

<para>note:</para><para>Only possible for string data types.</para><para>The written string will be transformed from the Unicode or MBCS input string, depending on the library.</para><para>The written string always will be zero terminated. In case it is too long, it will be truncated.</para></summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[in] string value to write (must not be null)</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WriteRawValue(Vector.Mdf4LibDotNet.IChannel,System.Byte[],System.Boolean)">
            <summary>
Write the raw value (given as BYTE array) for the given channel

<para>note: for numeric values, the value bytes will be written!</para></summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="byteArray">[in] buffer for the Byte array to write (must not be null)</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WriteRawValue(Vector.Mdf4LibDotNet.IChannel,System.Int64,System.Boolean)">
            <summary>
Write the raw value (given as Integer value) for the given channel
</summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[in] value to write</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WriteRawValue(Vector.Mdf4LibDotNet.IChannel,System.Double,System.Boolean)">
            <summary>
Write the raw value (given as double value) for the given channel
</summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[in] value to write</param>
            <param name="isValid">[in] in case MDF4 invalidation bit is used for this channel,
the invalidation bit will be set for isValid = false, or reset if isValid = true (default).</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.SetTimeSec(System.Double)">
            <summary>
Set time stamp in seconds in current record
<para>note: the time stamp should be larger than time stamp of previous record!</para>
Depending on the configured TimeCheckMode (see SetTimeCheckMode), the method may detect reverse time stamps and return eReverseTimeStamp, but the time stamp
will be set nevertheless!
Not possible in case a virtual time channel is used.
</summary>
            <param name="timeStampSec">[in] time stamp in seconds</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.SetTimeNs(System.Int64)">
            <summary>
Set time stamp in nanoseconds in current record
<para>note: the time stamp should be larger than time stamp of previous record!</para>
Depending on the configured TimeCheckMode (see SetTimeCheckMode), the method may detect reverse time stamps and return eReverseTimeStamp, but the time stamp
will be set nevertheless!
Not possible in case a virtual time channel is used.
</summary>
            <param name="timeStampNs">[in] time stamp in nanoseconds</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.WriteRecord(System.Byte[],System.Byte[])">
            <summary>
Write a complete record

<para>note: writing a complete record is not possible if the channel group of the record contains a VLSD channel!</para>
For optimized performance the record data (and possibly invalidation) Bytes may be assembled in the calling application and written directly.
Any previously set time stamps or values and invalidation bits in the record will be overwritten!
Depending on the configured FlushCheckMode (see SetFlushCheckMode), the method may detect this and return eNoFlushSinceLastValue, but the
record will be written nevertheless!
Depending on the configured TimeCheckMode (see SetTimeCheckMode), the method may detect reverse time stamps and return eReverseTimeStamp,
but the record will be written nevertheless!
<para>note: min/max value statistics for the individual channels are not updated when using this method.</para></summary>
            <param name="dataBytes">[in] buffer for the data Bytes to write (must not be null)</param>
            <param name="invalBytes">[in] buffer for the invalidation Bytes to write (optional, MDF4 only). If null, all used invalidation bits will be reset.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.FlushRecord">
            <summary>
Flush the current record to file

<para>note: the method also prepares the new record, i.e. record filled with zeros and all invalidation bits are set.</para><para>Depending on the configured FlushCheckMode (see SetFlushCheckMode), the method may detect that not all channel values were set
and return eFlushNotAllValuesWritten, but the record will be written nevertheless!
Depending on the configured TimeCheckMode (see SetTimeCheckMode), the method may detect reverse time stamps and return
eReverseTimeStamp, but the record will be written nevertheless!</para></summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.SetWriteMode(Vector.Mdf4LibDotNet.DataWriteMode)">
            <summary>
Set the current write mode to use
<para>note: the write mode influences all Write methods</para></summary>
            <param name="mode">[in] mode write mode to set, see DataWriteMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.GetWriteMode">
            <summary>
Get the current write mode
<para>see: SetWriteMode</para></summary>
            <returns>current read mode, see DataWriteMode</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.GetRecordCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataWriter.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the number of records in data
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>the number of records or 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataWriter.AttachToCurrentThread">
            <summary>
Attach this object to the current thread

This method can be used in case IFile was opened with allowMultiThreading = true
to improve performance when using the IDataWriter object in current thread only.
After calling the method, the object cannot be used in any other thread any longer
(except when calling AttachToCurrentThread again within the new thread!).
<para>see: IFileManager::CreateFile or IFileManager::OpenFile</para></summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IDataWriter">
            <summary>
Object for writing signal data

The IDataWriter object can be used to write signal data.

A data writer is created for a channel group (by IChannelGroup::CreateDataWriter).
There can be only one data writer object at one time.
It must be released before opening a data writer for another channel group.
note:
For MDF3, it is not possible to create any other elements (MDF blocks) before release of the data writer object.

The signal values are stored in records.
The content of a record is defined by the channels of the respective channel group.
All signal values in a record have the same time stamp.

The data writer allows to append records to the record stream of the respective channel group.
The writing of a single record is called to "flush" the record.
The data writer always creates sorted data.

A record contains the data bytes for the values of the channels contained in the channel group.
For MDF4, it may also contain additional bytes for the invalidation bits used by the channels.
With invalidation bits it is possible to invalidate a single value within a specific record.

Using the Write/SetTime methods, the signal value(s) for a specific channel can be written to the currently accessed record.
It is also possible to write the complete record in one go using IDataWriter::WriteRecord.

There are three ways to use a data writer which usually should not be mixed:
<para>Assembling the record in your own code and writing the complete record with IDataWriter::WriteRecord.
This method immediately flushes the record, i.e. writes it to the stream of records.
An explicit call to IDataWriter::FlushRecord is not necessary.</para>
This is the fastest way to write records.
<para>Setting the flush check mode (see IDataWriter::SetFlushCheckMode) to eFlushCheckDuringWrite or eFlushCheckAll, then
IDataWriter::WriteRecord checks if any Write/SetTime method was used for the currently accessed record.
In case signal values have been set to the current record, IDataWriter::WriteRecord will indicate thsi by return value eNoFlushSinceLastValue (warning),
but the record will be overwritten nevertheless!</para><para>Setting the flush check mode to eFlushCheckDisabled or eFlushCheckDuringFlush, there will be no check in IDataWriter::WriteRecord.</para><para>Setting the write mode to eAutoFlush (see IDataWriter::SetWriteMode).
The signal values can be set to the currently accessed record using Write/SetTime methods for all channels contained in the channel group.
Whenever a Write/SetTime method detects that a channel value already is set in the current record (the channel is "dirty"), it automatically flushes the record.
An explicit call to IDataWriter::FlushRecord is not necessary. The last record will be written when the IDataWriter object is released.</para><para>Setting the flush check mode to eFlushCheckDuringFlush or eFlushCheckAll, then the automatic flush will check if all channels are dirty.
In case one or more channels are not dirty, the respective Write/SetTime method reports an error and the automatic flush does not occur.
Note that this check may not work correctly when using structures or signals with overlapping bytes in the record.</para><para>Setting the flush check mode to eFlushCheckDisabled or eFlushCheckDuringFlush, there will be no check. During a flush, non-dirty channel values will be
filled with zeros and, if used, the invalidation bits will be set for these channels.</para><para>Setting the write mode to eSetValue (using IDataWriter::SetWriteMode).
In this case after setting the values with the Write/SetTime methods, an explicit call to IDataWriter::FlushRecord is required.</para><para>Setting the flush check mode to eFlushCheckDuringFlush or eFlushCheckAll, IDataWriter::FlushRecord will return eFlushNotAllValuesWritten
as warning in case not all channels are dirty.
Non-dirty channel values will be filled with zeros and, if used, the invalidation bits will be set for these channels.</para><para>Setting the flush check mode to eFlushCheckDuringWrite or eFlushCheckAll, the Write/SetTime method will return eNoFlushSinceLastValue in
case the channel already is dirty. In this case, the existing value will not be overwritten.</para><para>Without flush check mode (::eFlushCheckDisabled), there is no check. In this case, Write/SetTime will overwrite an already set value.</para><para>It is also possible to let the IDataWriter check the time stamps and report an error/warning in case of reverse time stamps. For details
see IDataWriter::SetTimeCheckMode.</para></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadInvalBytesOfRecord(System.UInt32,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadInvalBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadInvalBytesOfRecord(System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadInvalBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadInvalBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadDataBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)" /></summary>
            <summary>
                <para>Read parts of the record invalidation bytes</para>
                <para>note: consider IChannelGroup::GetInvalByteCount()</para>
            </summary>
            <param name="offset">[in] offset in Bytes from start of invalidation bytes</param>
            <param name="count">[in] number of bytes to read
            <br />if offset + count exceeds the number of invalidation bytes, the method returns an error code ::eInvalidArgument</param>
            <param name="byteArray">[out] buffer to receive the result.
<ul><li>If byteArray is null or count is larger than size of byteArray, byteArray will be re-allocated with the correct size.</li><li>If count is less than size of byteArray, only consider the respective number of bytes.</li></ul></param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadDataBytesOfRecord(System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadDataBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadDataBytesOfRecord(System.UInt32,System.UInt32,System.Byte[]@)">
            <summary>
                <para>Read parts of the record data bytes</para>
                <para>note: consider IChannelGroup::GetDataByteCount()</para>
            </summary>
            <param name="offset">[in] offset in Bytes from start of record</param>
            <param name="count">[in] number of bytes to read
            <br />if offset + count exceeds the number of data bytes, the method returns an error code ::eInvalidArgument</param>
            <param name="byteArray">[out] buffer to receive the result.
<ul><li>If byteArray is null or count is larger than size of byteArray, byteArray will be re-allocated with the correct size.</li><li>If count is less than size of byteArray, only consider the respective number of bytes.</li></ul></param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.CanReadChannelValueFlags)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.CanReadChannelValueAsPhysDouble(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.CanReadChannelValueFlags)">
            <summary>
                <para>Check if values of the given channel can be read as PhysValueDouble in general</para>
                <para>This function may help to decide whether to use a MultiReadPhysValueDouble method or iterate over all records and check each result individually.
It considers the options to ignore some warnings specified at creating the IDataPointer (see IChannelGroup::CreateDataPointerEx).</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="options">[in] bit combination of option flags, see ::CanReadChannelValueFlags</param>
            <returns>error code of the operation:
<br />::eOK if PhysValueDouble methods can safely be used
<br />::eInvalidDataTypeForOperation if IChannel neither has not a numeric data type nor a conversion of type ::eText2Value
<br />::eDifferentCoversionResultType if IChannel has a conversion with text output
<br />::eStatusStringTableEntry if IChannel has a status string table conversion
<br />::eFatalFormatError in case of invalid conversion
<br />::eDivisionByZero or ::eLogarithmOfZero in conversion always delivers this result (still can happen for indvidualy channel values!)
<br />::eNoDataAvailable if there are no channel values
<br />... (other error codes possible)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for each of the given channels as double values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadRawValueDouble, but can reads the values of a number of channels and (optionally) the time stamps in ns.
For details see description there.</para>
            </summary>
            <param name="channels">[in] channels to use for this operation.</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns.
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value arrays,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="valueArrays">[out] array of array buffers to receive the result values for the respective channel in channels.
the array must contain an array buffer for each channel in channels.</param>
            <param name="arrayElements">[in] length of each array buffer in valueArrays, i.e. maximum number of elements (values) that can be stored in case of interval = 1.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in each array given by valueArrays[i] will be fille.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDoubleOfMultipleChannels(Vector.Mdf4LibDotNet.IChannel[],System.Int64[]@,System.Double[][]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of physical values for each of the given channels as double values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadPhysValueDouble, but can reads the values of a number of channels and (optionally) the time stamps in ns.</para>
For details see description there.
</summary>
            <param name="channels">[in] channels to use for this operation.</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns.
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value arrays,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="valueArrays">[out] array of array buffers to receive the result values for the respective channel in channels.
the array must contain an array buffer for each channel in channels.</param>
            <param name="arrayElements">[in] length of each array buffer in valueArrays, i.e. maximum number of elements (values) that can be stored in case of interval = 1.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in each array given by valueArrays[i] will be fille.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Byte[][]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Byte[][]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Byte[][]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as byte arrays and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadRawValueByteArray, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns (can be null).
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="bufferArray">[out] array buffer to receive the results, i.e. the values as byte arrays</param>
            <param name="arrayElements">[in] maximum number of elements (byte arrays) that can be stored.</param>
            <param name="elementBufferSize">[in] How many elements should be read in each individual array, 0 to read all.</param>
            <param name="dataSizeArray">[out] How much data has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of bufferArray.
For interval &gt; 1, the values will be stored with intervals like for bufferArray.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by bufferArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as string values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadRawValueString, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns (can be null).
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="stringArray">[out] string array buffer to receive the result strings</param>
            <param name="arrayElements">[in] maximum number of elements (strings) that can be read.</param>
            <param name="stringSize">[in] size of the string in characters that has to be read in stringArray[i] or 0 to read the complete value.</param>
            <param name="dataSizeArray">[out] How many characters has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of stringArray.
For interval &gt; 1, the values will be stored with intervals like for stringArray.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by ppStringArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Int64[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Int64[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Int64[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as Integer values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadRawValueInt64, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns (can be null).
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="valueArray">[out] array buffer to receive the result values.</param>
            <param name="arrayElements">[in] maximum number of elements (values/time stamps) that can be read. 0 to read all.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as double values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadRawValueDouble, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns (can be null).
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array,
i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="valueArray">[out] array buffer to receive the result values.</param>
            <param name="arrayElements">[in] maximum number of elements (values/time stamps) that can be read. 0 to read all.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of phys values for the given channel as string values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadPhysValueString, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns (can be null)
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array,
i.e. at least (arrayElements+interval - 1) / interval.</param>
            <param name="stringArray">[out] string array buffer to receive the result strings</param>
            <param name="arrayElements">[in] maximum number of elements (strings) that should be read.</param>
            <param name="stringSize">[in] size of the string in characters that has to be read in stringArray[i] or 0 to read the complete value.</param>
            <param name="dataSizeArray">[out] How many characters has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of stringArray.
For interval &gt; 1, the values will be stored with intervals like for stringArray.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by stringArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadTimeNsAndPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of physical values for the given channel as double values and the respective time stamps in ns in one go</para>
                <para>This function is similar to MultiReadPhysValueDouble, but also reads the time stamps in ns. For details see description there.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="timeStampArrayNs">[out] optional array buffer to receive the time stamps in ns.
Note that the time values are always stored consecutively, independent of parameter interval.
The length of the array must be large enough to store as many time stamps as values can be stored in the value array, i.e. at least (arrayElements + interval - 1) / interval.</param>
            <param name="valueArray">[out] array buffer to receive the result values</param>
            <param name="arrayElements">[in] maximum number of elements that should be read. 0 to read all</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetZipType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetZipType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetZipType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the compression ("zip") type</para>
                <para>note: compression is only available for MDF 4.1 or higher. Older versions never have a compression.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>compression type used for the (main) data block (see ZipType), or eZipTypeUnspec in case of error or if no compression is used</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.Inc(System.UInt64)">
            <summary>
                <para>Increment record position</para>
                <para>note: same as SeekPos(steps, eSeekRelative), except that this also works for unsorted data</para>
            </summary>
            <param name="steps"> number of steps to increment, default is 1 (forward only!)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.SeekFirst">
            <summary>
                <para>Seek the first record</para>
                <para>note: same as SeekPos(0), except that this also works for unsorted data</para>
                <para>Resets the pointer to the start</para>
            </summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadInvalBitState(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadInvalBitState(Vector.Mdf4LibDotNet.IChannel,System.Boolean[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadInvalBitState(Vector.Mdf4LibDotNet.IChannel,System.Boolean[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadInvalBitState(Vector.Mdf4LibDotNet.IChannel,System.Boolean[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadInvalBitState(Vector.Mdf4LibDotNet.IChannel,System.Boolean[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of invalidation bit states for the given channel as Boolean values in one go</para>
                <para>This function allows to read a whole number of invalidation bit state values into an array of Boolean values.
Starting from the current position of IDataPointer, the next N bit state values will be stored
in the array.
By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th state value will be stored in pStateArray[(i-1)*interval] (i &gt; 0).</para>
                <para>State values will be stored until the end of pStateArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there are less state values present for the channel than can be stored, the method returns eReachedEndOfData.
In case there is some error during reading or converting a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>In case the channel has no invalidation bit, eNotAvailable will be returned.</para>
                <para>The respective element in the array will be set to true if invalidation bit is set for given channel, or to false otherwise or on error.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="stateArray">[out] array buffer to receive the state values</param>
            <param name="arrayElements">[in] maximum number of elements that should be read. 0 to read all</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store state values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by pStateArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetInvalBitState(Vector.Mdf4LibDotNet.IChannel,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Request the state of the invalidation bit for the given channel</para>
                <para>note: invalidation bits are not available for MDF3 and optional for MDF4</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>true if invalidation bit is set for given channel, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArrayIntoStream(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArrayIntoStream(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArrayIntoStream(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as Byte arrays into a Byte stream</para>
                <para>This function allows to read a whole number of signal values into a stream buffer.</para>
                <para>note: In contrast to MultiReadRawValueByteArray the size of a single value is not restricted!
Starting from the current position of IDataPointer, its next N values will be stored
in the stream buffer.
By default (offset = 0) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter offset &gt; 0, a gap of offset Bytes will be left between the last Byte of one value and the first Byte of the next value (see Example below).</para>
                <para>At most maxElementsToRead values will be stored. The routine also stops</para>
                <para>if the end of pByteStream is reached (return value eResultBufferTooSmall), or</para>
                <para>if there are no more values (return value eReachedEndOfData).</para>
                <para>In case there is some error during reading a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="byteStream">[out] stream buffer to store the raw values</param>
            <param name="streamLength">[in] stream length that has to be allocated for reading</param>
            <param name="maxElementsToRead">[in] maximum number of elements to read</param>
            <param name="dataSizeArray">[out] the actual size of the data in Bytes will be returned for each read value.
the length of dataSizeArray (i.e. the number of elements) must be at least maxElementsToRead.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= maxElementsToRead)</param>
            <param name="offset">[in] offset in Bytes, i.e. number of Bytes to skip after end of one value and begin of next value.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[][]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[][]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[][]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[][]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as byte arrays in one go</para>
                <para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, its next N values will be stored
in the value buffer.</para>
                <para>By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in ppBufferArray[(i-1)*interval] (i &gt; 0).</para>
                <para>Values will be stored until the end of ppBufferArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there is some error during reading a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="bufferArray">[out] array to receive the result arrays</param>
            <param name="arrayElements">[in] maximum number of elements that should be read.</param>
            <param name="elementBufferSize">[in] How many elements should be read in each individual array, 0 to read all.</param>
            <param name="dataSizeArray">[out] How much data has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of bufferArray.
For interval &gt; 1, the values will be stored with intervals like for bufferArray.</param>
            <param name="elementsRead">[out] Number of elements read in the array.</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by bufferArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as string values in one go</para>
                <para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, its next N values will be stored
in the value buffer.
By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in ppStringArray[(i-1)*interval] (i &gt; 0).</para>
                <para>Values will be stored until the end of ppStringArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there is some error during reading a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Only possible for string data types.</para>
                <para>Not supported for unsorted data (see IsDataSorted())</para>
                <para>Each string will be transformed to Unicode or MBCS depending on the library.</para>
                <para>Each result string always is zero terminated.</para>
                <para>Please note that the stringBufferSize is in Bytes and not in characters.</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="stringArray">[out] string array to receive the result strings</param>
            <param name="arrayElements">[in] maximum number of elements that should be read.</param>
            <param name="stringSize">[in] How many characters should be read in each individual string, 0 to read all.</param>
            <param name="dataSizeArray">[out] How many characters has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of stringArray.
For interval &gt; 1, the values will be stored with intervals like for stringArray.</param>
            <param name="elementsRead">[out] Number of elements read in the array.</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the string given by stringArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of raw values for the given channel as Integer values in one go</para>
                <para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, its next N values will be stored
in the value buffer.
By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in valueArray[(i-1)*interval] (i &gt; 0).</para>
                <para>Values will be stored until the end of valueArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there is some error during reading a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] to use for this operation</param>
            <param name="valueArray">[out] array buffer to receive the result values</param>
            <param name="arrayElements">[in] maximum number of elements that should be read. 0 to read all</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
Read a number of raw values for the given channel as double values in one go

<para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, its next N values will be stored
in the value buffer.
By default (interval = 1) the values will be stored consecutively.</para><para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in valueArray[(i-1)*interval] (i &gt; 0).</para><para>Values will be stored until the end of valueArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there are less values present for the channel than can be stored, the method returns eReachedEndOfData.
In case there is some error during reading or converting a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para><para>note:</para><para>Not supported for unsorted data (see IsDataSorted()).</para><para>By default, after reading the values, the original record position will be restored.</para><para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para></summary>
            <param name="channel">[in] to use for this operation</param>
            <param name="valueArray">[out] array buffer to receive the result values.</param>
            <param name="arrayElements">[in] maximum number of elements that should be read.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String[]@,System.UInt32,System.UInt32,System.UInt32[]@,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of phys values for the given channel as string values in one go</para>
                <para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, its next N values will be stored
in the value buffer.
By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in ppStringArray[(i-1)*interval] (i &gt; 0).</para>
                <para>Values will be stored until the end of ppStringArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there is some error during reading a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Only possible if conversion returns a string or 1:1 conversion for string data types.</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>Each string will be transformed to Unicode or MBCS depending on the library.</para>
                <para>Each result string always is zero terminated.</para>
                <para>Please note that the stringBufferSize is in Bytes and not in characters.</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="stringArray">[out] string array to receive the result strings</param>
            <param name="arrayElements">[in] maximum number of elements that should be read.</param>
            <param name="stringSize">[in] How many characters should be read in each individual string, 0 to read all.</param>
            <param name="dataSizeArray">[out] How much data has been read in each corresponding object.
The length of dataSizeArray (i.e. the number of elements) must be equal to the size of stringArray.
For interval &gt; 1, the values will be stored with intervals like for stringArray.</param>
            <param name="elementsRead">[out] Number of elements read in the array.</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the string given by stringArray will be filled.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.MultiReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double[]@,System.UInt32,System.UInt32@,System.UInt32)">
            <summary>
                <para>Read a number of physical values for the given channel as double values in one go</para>
                <para>This function allows to read a whole number of signal values into a value buffer.
Starting from the current position of IDataPointer, the next N values will be stored
in the value buffer.
By default (interval = 1) the values will be stored consecutively.</para>
                <para>Alternatively, using parameter interval &gt; 1, the values can be stored with intervals.
In this case, the i-th value will be stored in valueArray[(i - 1) * interval] (i &gt; 0).</para>
                <para>Values will be stored until the end of valueArray is reached, i.e. 1 + (int)((arrayElements-1)/interval).
In case there are less values present for the channel than can be stored, the method returns eReachedEndOfData.
In case there is some error during reading or converting a value, the loop will be aborted and the error code will be returned.
You should examine the contents of pElementsRead to find out how many values have been actually stored.</para>
                <para>note:</para>
                <para>Not supported for unsorted data (see IsDataSorted()).</para>
                <para>In case there is no conversion rule, the raw value will be returned (1:1 conversion)</para>
                <para>By default, after reading the values, the original record position will be restored.</para>
                <para>This can be disabled with option eDisableAutoRestorePos for CreateDataPointerEx.</para>
            </summary>
            <param name="channel">[in] to use for this operation</param>
            <param name="valueArray">[out] array buffer to receive the result values</param>
            <param name="arrayElements">[in] maximum number of elements that should be read.</param>
            <param name="elementsRead">[out] this argument returns the number of elements actually read (&lt;= (arrayElements + interval - 1) / interval)</param>
            <param name="interval">[in] this parameter can be used to store values from different channels alternating in the value buffer (must not be 0).
For interval &gt; 1 thus only each x-th element in the array given by valueArray will be filled</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.UInt32@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.UInt32@,System.Boolean@)">
            <summary>
                <para>Read the raw value for the given channel as string</para>
                <para>note:</para>
                <para>Only possible for string data types.</para>
                <para>The string will be transformed to Unicode.</para>
                <para>The result string always is zero terminated.</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="stringBuffer">[out] buffer to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific number of characters.</param>
            <param name="actualSize">[out] The actual size of the data in characters will be returned.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.UInt32@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueByteArray(Vector.Mdf4LibDotNet.IChannel,System.Byte[]@,System.UInt32,System.UInt32@,System.Boolean@)">
            <summary>
                <para>Read the raw value for the given channel as BYTE array</para>
                <para>note: for numeric values, the value bytes will be assigned!</para>
            </summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="byteArray">[out] buffer to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific size.</param>
            <param name="actualSize">[out] the actual size of the data in Bytes will be returned:
If data size is less than readSize, only consider the respective number of bytes.
If data size is larger than readSize, not all Bytes have been copied
and the return code will be eResultBufferTooSmall.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueInt64(Vector.Mdf4LibDotNet.IChannel,System.Int64@,System.Boolean@)">
            <summary>
Read the raw value for the given channel as Integer value
</summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result (must not be null)</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadRawValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@)">
            <summary>
Read the raw value for the given channel as double value
</summary>
            <param name="channel">[in] channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result (must not be null)</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.UInt32@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueString(Vector.Mdf4LibDotNet.IChannel,System.String@,System.UInt32,System.UInt32@,System.Boolean@)">
            <summary>
                <para>Read the phys value for the given channel as string</para>
                <para>note:</para>
                <para>Only possible if conversion returns a string or 1:1 conversion for string data types.</para>
                <para>The string will be transformed to Unicode.</para>
                <para>The result string always is zero terminated.</para>
            </summary>
            <param name="channel">[in] to use for this operation</param>
            <param name="stringBuffer">[out] buffer to receive the result</param>
            <param name="readSize">[in] Pass 0 if all data has to be read or count for a specific number of characters.</param>
            <param name="actualSize">[out] The actual size of the data in characters will be returned.</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.ReadPhysValueDouble(Vector.Mdf4LibDotNet.IChannel,System.Double@,System.Boolean@)">
            <summary>
                <para>Read the physical value for the given channel as double value</para>
                <para>note: in case there is no conversion rule, the raw value will be returned (1:1 conversion)</para>
            </summary>
            <param name="channel">[in] channel channel to use for this operation</param>
            <param name="value">[out] buffer to receive the result (must not be null)</param>
            <param name="isValid">[out] false will be assigned for MDF4 if all values are invalid or the invalidation bit is set, otherwise true</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeSec">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeSec(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get time stamp in seconds for current record position</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>time stamp in seconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeNs">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetTimeNs(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get time stamp in nanoseconds for current record position</para>
                <para>note: for virtual time master channels, the virtual time will be returned</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>time stamp in nanoseconds or 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.SeekTimeSec(System.Double,Vector.Mdf4LibDotNet.SeekTimeMode)">
            <summary>
                <para>Seek record position with specific time stamp in seconds</para>
                <para>note: currently only available for sorted data!</para>
                <para>see: GetTimeNs</para>
            </summary>
            <param name="time">[in] time stamp in seconds to seek</param>
            <param name="mode">[in] mode for seek, see SeekTimeMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.SeekTimeNs(System.Int64,Vector.Mdf4LibDotNet.SeekTimeMode)">
            <summary>
                <para>Seek record position with specific time stamp in nanoseconds</para>
                <para>note: currently only available for sorted data!</para>
                <para>see: GetTimeNs</para>
            </summary>
            <param name="time">[in] time stamp in nanoseconds to seek</param>
            <param name="mode">[in] mode for seek, see SeekTimeMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.SeekPos(System.UInt64,Vector.Mdf4LibDotNet.SeekPosMode)">
            <summary>
                <para>Seek the record position (i.e. zero-based index)</para>
                <para>note: currently only available for sorted data!</para>
                <para>see: GetPos, IsDataSorted</para>
            </summary>
            <param name="pos">[in] position to seek, depending on mode (zero-based index)</param>
            <param name="mode">[in] mode for seek, see SeekPosMode, default is eSeekAbsolute</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetPos">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetPos(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get current record position (i.e. zero-based index)</para>
                <para>see: SeekPos</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>zero-based index of current record or -1 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.SetReadMode(Vector.Mdf4LibDotNet.DataReadMode)">
            <summary>
Set the current read mode to use
<para>note: the read mode influences all Read methods</para></summary>
            <param name="mode">[in] read mode to set, see DataReadMode</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetReadMode">
            <summary>
                <para>Get the current read mode</para>
                <para>see: SetReadMode</para>
            </summary>
            <returns>current read mode, see DataReadMode</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetRecordCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetRecordCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get the number of records in data
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>the number of records or 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.IsDataSorted">
            <summary>
                <para>Check if data pointer works on sorted data</para>
                <para>Sorted data allows indexed access. This may also be the case for
an unsorted data group if only one of the channel groups has records.</para>
                <para>note: In case of unsorted data, the methods SeekPos, SeekTimeNs and
SeekTimeSc are not allowed due to possible low performance.</para>
                <para>Consider sorting the file before with IFileManager::SortFile or
using methods SeekFirst and Inc.</para>
                <para>see: SeekPos, SeekTimeNs, SeekTimeSec, SeekFirst, Inc</para>
                <para>A data pointer may contain sorted data even if IChannelGroup::IsSorted of
its channel group returns false.
This may be the case if the parent data group contains
several channel groups, but only one of them has samples.</para>
            </summary>
            <returns>true if data is sorted, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.AttachToCurrentThread">
            <summary>
                <para>Attach this object to the current thread</para>
                <para>This method can be used in case IFile was opened with allowMultiThreading = true
to improve performance when using the IDataPointer object in current thread only.
After calling the method, the object cannot be used in any other thread any longer
(except when calling AttachToCurrentThread again within the new thread!).</para>
                <para>see: IFileManager::OpenFile</para>
            </summary>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IDataPointer.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IDataPointer">
            <summary>
                <para>Access to signal data</para>
                <para>The IDataPointer object gives access to the signal data.</para>
                <para>Signal values are always stored in records.
The data pointer allows to navigate in the record stream:</para>
                <para>for sorted data a random access is possible,
i.e. either by seeking a position (i.e. zero-based index)
or by seeking a time value (other master channel types are not supported yet).</para>
                <para>for unsorted data only a forward increment is possible,
e.g. using the Inc method or the AutoIncrement read mode.</para>
                <para>Using the Read methods, the signal value(s) of a specific channel within the data record(s)
can be obtained.</para>
                <para>A data pointer can be created either for a channel group or for a channel
(IChannelGroup::CreateDataPointer and IChannel::CreateDataPointer).</para>
                <para>note: for faster reading use the extended methods IChannelGroup::CreateDataPointerEx resp. IChannel::CreateDataPointerEx and
specify using a read buffer. Especially in combination with the MultiRead methods, this will be the fastest way to read a larger number of signal values.</para>
                <para>Created for a channel group, the data pointer gives access to the signal data of all channels
in the channel group.</para>
                <para>Created for a channel, only the values of this channel and its time stamps can be read
(possibly better performance if only signal values of this channel are of interest).</para>
                <para>note: For an array channel (CompositionType eIsArray), some of its child channels may <b>NOT</b> be part of
the parent channel group! This may happen for MDF3 in case of a distributed CD block (old way to store 2D maps)
or for MDF4 in case of a CA block with CG/DG template (not supported yet!)</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetUserName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetUserName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetUserName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get user name</para>
                <para>Returns the contents of the &lt;user_name&gt; tag with name/identification of the user who has written this log entry.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to text or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolVersion">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolVersion(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolVersion(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get tool version</para>
                <para>Returns the contents of the &lt;tool_version&gt; tag with version info about the tool that has written this log entry.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to text or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetVendorName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetVendorName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetVendorName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get name of vendor</para>
                <para>Returns the contents of the &lt;tool_vendor&gt; tag with name of the vendor/author of the tool that has written this log entry.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to text or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetToolName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get name of tool</para>
                <para>Returns the contents of the &lt;tool_id&gt; tag with name/identification of the tool that has written this log entry.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to text or null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetTimeStamp">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetTimeStamp(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetTimeStamp(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get new reference to time stamp object of the creator info</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>interface pointer for ITimeStamp object</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get comment of creator info</para>
                <para>note: for creator info (MDF4), it is always an XML string</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICreatorInfo.GetIndex">
            <summary>
                <para>Get index in global list of file history entries</para>
                <para>note: index 0 means that this is the creator info of the file</para>
                <para>see: IFile::GetCreatorInfo</para>
            </summary>
            <returns>zero-based index</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ICreatorInfo">
            <summary>
                <para>Information about the creator of an object</para>
                <para>The ICreatorInfo describes who/which tool generated or changed the MDF file or an element.</para>
                <para>It represents the content of a FH block for MDF4. For MDF3 there is no equivalent information.</para>
                <para>For MDF4, the list of FH blocks contains the change history of the MDF file.</para>
                <para>The log entries can be accessed by IFile::GetFileHistoryLog.</para>
                <para>For the main creator of the MDF file, use IFile::GetCreatorInfo, which should be equal to IFile::GetFileHistoryLog(0).</para>
                <para>The IAttachment and the IEvent object, or the meta info in XML also contain information about the creator info, i.e. who/which tool
generated or changed it (IAttachment::GetCreatorInfo / IEvent::GetCreatorInfo)</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueTextOrConversion">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueTextOrConversion(Vector.Mdf4LibDotNet.TextOrConversion@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueTextOrConversion(Vector.Mdf4LibDotNet.TextOrConversion@)">
            <summary>
Get default value of a conversion table (text or IConversion)
</summary>
            <para>Note:  only available for the following conversion types: ::eValue2Text, ::eValueRange2Text, ::eText2Text. The default value is optional for these conversion types.</para>
            <param name="result">[out] will be assigned to the default value (text or IConversion)
            The result can be a text or an IConversion object.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueDouble">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueDouble(System.Double@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableDefaultValueDouble(System.Double@)">
            <summary>
Get default value of a conversion table (double)
</summary>
            <para>Note:  only available for the following conversion types: ::eValueRange2Value and ::eText2Value</para>
            <param name="result">[out] will be assigned to the default value (double)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValueRange2Text(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries of status string table with value range 2 text conversion
</summary>
            <para>Note:  only available if GetStatusStringTableType() returns ::eValueRange2Text</para>
            <param name="valueRange2TextArray">[out] array buffer to receive the key-value pairs of the status string table</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in valueRange2TextArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetStatusStringTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValue2Text(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries of status string table with value 2 text conversion
</summary>
            <para>Note:  only available if GetStatusStringTableType() returns ::eValue2Text</para>
            <param name="value2TextArray">[out] array buffer to receive the key-value pairs of the status string table</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in value2TextArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetStatusStringTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2TextOrConversion(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2TextOrConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2TextOrConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2TextOrConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2TextOrConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value range 2 text conversion or a partial conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eValueRange2Text.
            If GetPartialConversion() returns false, there should be only texts in the result buffer. In this case you also may use GetTableEntriesValueRange2Text().</para>
            <param name="valueRange2TextOrConversionArray">[out] array buffer to receive the key-value pairs</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in valueRange2TextOrConversionArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2TextOrConversion(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2TextOrConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2TextOrConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2TextOrConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2TextOrConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value 2 text conversion or a partial conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eValue2Text.
            If GetPartialConversion() returns false, there should be only texts in the result buffer. In this case you also may use GetTableEntriesValue2Text().</para>
            <param name="value2TextOrConversionArray">[out] array buffer to receive the key-value pairs. </param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in value2TextOrConversionArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Text(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Text(Vector.Mdf4LibDotNet.ValueRange2Text[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value range 2 text conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eValueRange2Text and if IsPartialConversion() returns false.
            In case of a partial conversion, please use GetTableEntriesValueRange2TextOrConversion().</para>
            <param name="valueRange2TextArray">[out] array buffer to receive the key-value pairs.</param>
            <param name="arrayElements"> length of array, i.e.maximum number of table entries that can be stored in valueRange2TextArray(must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Text(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Text(Vector.Mdf4LibDotNet.Value2Text[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value 2 text conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eValue2Text and if IsPartialConversion() returns false.
            In case of a partial conversion, please use GetTableEntriesValue2TextOrConversion().</para>
            <param name="value2TextArray">[out] array buffer to receive the key-value pairs</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in value2TextArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Text(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Text(Vector.Mdf4LibDotNet.Text2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Text(Vector.Mdf4LibDotNet.Text2Text[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Text(Vector.Mdf4LibDotNet.Text2Text[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Text(Vector.Mdf4LibDotNet.Text2Text[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a text 2 text conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eText2Text </para>
            <param name="text2TextArray">[out] array buffer to receive the key-value pairs.</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in text2TextArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Value(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Value(Vector.Mdf4LibDotNet.Text2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Value(Vector.Mdf4LibDotNet.Text2Value[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Value(Vector.Mdf4LibDotNet.Text2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesText2Value(Vector.Mdf4LibDotNet.Text2Value[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value text 2 value conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eText2Value</para>
            <param name="text2ValueArray">[out] array buffer to receive the key-value pairs</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in text2ValueArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Value(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Value(Vector.Mdf4LibDotNet.ValueRange2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Value(Vector.Mdf4LibDotNet.ValueRange2Value[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Value(Vector.Mdf4LibDotNet.ValueRange2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValueRange2Value(Vector.Mdf4LibDotNet.ValueRange2Value[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value range 2 value conversion
</summary>
            <para>Note:  only available for the following conversion type: ::eValueRange2Value </para>
            <param name="valueRange2ValueArray">[out] array buffer to receive the key-value pairs</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in valueRange2ValueArray (must not be 0).
           arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            See also example for GetTableEntriesValue2Value().</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Value(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Value(Vector.Mdf4LibDotNet.Value2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Value(Vector.Mdf4LibDotNet.Value2Value[]@,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Value(Vector.Mdf4LibDotNet.Value2Value[]@,System.UInt32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntriesValue2Value(Vector.Mdf4LibDotNet.Value2Value[]@,System.UInt32,System.UInt32)">
            <summary>
Get list of table entries for a value 2 value conversion
</summary>
            <para>Note:  only available for the following conversion types: ::eValue2ValueInterpol and ::eValue2ValueNoInterpol.</para>
            <param name="value2ValueArray">[out] array buffer to receive the key-value pairs</param>
            <param name="arrayElements"> length of array, i.e. maximum number of table entries that can be stored in value2ValueArray (must not be 0).
            arrayElements may be smaller or larger than the actual number of table entries. See GetTableEntryCount().</param>
            <param name="startElement"> element to start with, i.e. first table entry to insert into list, 0 to start with first element (default).
            This can be used to fetch only a sub range of the table entries or even a single table entry if arrayElements is 1.
            <b>Example 1:</b>
            Assume the table has 10 entries and the method is called with an array buffer with arrayElements = 5 elements and startElement = 2.
            In this case, the table entries with (zero-based) indices 2, 3, 4, 5, 6 will be stored.
            <b>Example 2:</b> same as Example 1, but startElement = 7.
            In this case, the table entries with (zero-based) indices 7, 8, 9 will be stored (index 9 is the last table entry).
            </param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntryCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntryCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableEntryCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of entries for a status string table
</summary>
            <para>Note:  only available if HasStatusStringTable() returns true.</para>
            <para>See <see cref="M:Vector.Mdf4LibDotNet.IConversion.HasStatusStringTable" /> and <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.Value2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" />.</para>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>number of status string table entries, 0 on error or if no status table available (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntryCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntryCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetTableEntryCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of entries for a conversion table
<para>Note:  only available for the following conversion types:
<ul><li>::eValue2ValueInterpol: use GetTableEntriesValue2Value() to access the table entries.</li><li>::eValue2ValueNoInterpol: use GetTableEntriesValue2Value() to access the table entries.</li><li>::eValueRange2Value: use GetTableEntriesValueRange2Value() to access the table entries.</li><li>::eValue2Text: use GetTableEntriesValue2Text() or GetTableEntriesValue2TextOrConversion() (in case of a partial converison) to access the table entries.</li><li>::eValueRange2Text: use GetTableEntriesValueRange2Text() or GetTableEntriesValueRange2TextOrConversion() (in case of a partial converison) to access the table entries.</li><li>::eText2Value: use GetTableEntriesText2Value() to access the table entries.</li><li>::eText2Text: use GetTableEntriesText2Text() to access the table entries.</li></ul></para></summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>number of table entries, 0 on error or if no table available (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetFormulaText(Vector.Mdf4LibDotNet.SyntaxVersion)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetFormulaText(Vector.Mdf4LibDotNet.SyntaxVersion,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetFormulaText(Vector.Mdf4LibDotNet.SyntaxVersion,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get formula text for algebraic conversion
</summary>
            <para>Note:  only available for conversion type ::eAlgebraic</para>
            <para>See IFactory::CreateAlgebraicConversionEx() </para>
            <param name="syntaxVersion"> specifies the syntax version the formula text should be returned, see SyntaxVersion.
            ::eSyntaxVersionUnspec returns the formula text "as is".</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>formula text, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValues">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValues(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get all parameter values of formula
<para>See <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetParameterCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></para></summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>array of parameter values, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValue(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get parameter value of formula
<para>See <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetParameterCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></para><para>Note:  For a linear conversion, GetParameterValue(0) is the offset and GetParameterValue(1) is the factor.
Please refer to MDF specification for parameter definition of other conversion types (see IFactory::CreateRationalConversion()).</para></summary>
            <param name="index"> index of the parameter value to be returned</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>parameter value, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetParameterCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetParameterCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of parameter values of formula
<para>Note:  only the following conversion types have parameter values:
<ul><li>::eLinear: 2 parameters (offset and factor)</li><li>::eRational: 6 parameters</li><li>::ePolynomial: 6 parameters</li><li>::eExponential: 7 parameters</li><li>::eLogarithmic: 7 parameters</li></ul></para>
Please refer to MDF specification for exact parameter definition of the respective conversion type.
<para>See <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /> and <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></para></summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>number of parameter values, 0 on error or if not available (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetStatusStringTableType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get type of status string table
<para>Note:  only available if HasStatusStringTable() returns true.</para><para>See <see cref="M:Vector.Mdf4LibDotNet.IConversion.HasStatusStringTable" /> and <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.Value2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" />.</para>

If the method returns
<ul><li>::eValue2Text: use GetStatusStringTableEntriesValue2Text() to access the table entries.</li><li>::eValueRange2Text: use GetStatusStringTableEntriesValueRange2Text() to access the table entries.</li></ul></summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>type of status string table (either ::eValue2Text or ::eValueRange2Text), or
        ::eConversionTypeUnspec on error or if no status table available (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.IsPartialConversion">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.IsPartialConversion(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.IsPartialConversion(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Request if conversion is a partial conversion
</summary>
            <para>Note:  Partial conversions are only possible for MDF 4.x.
A status string table internally is modeled as partial conversion in MDF 4.x,
but this method only returns true if the main conversion is a partial conversion.</para>
            <para>See IFactory::CreatePartialConversion()</para>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>true if this is a partial conversion, false if not or on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetFile">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetFile(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetFile(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get reference to parent file
</summary>
            <returns>pointer to IFile object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.SetInverse(Vector.Mdf4LibDotNet.IConversion)">
            <summary>
                <para>Set inverse conversion</para>
                <para>note: only available for newly created or writable file and not available for MDF3 or for inverse conversion</para>
            </summary>
            <param name="conversion">[in] pointer to IConversion object for inverse conversion, null to remove reference for inverse conversion.
Note: object must be in same file.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.SetUnit(Vector.Mdf4LibDotNet.IUnit)">
            <summary>
                <para>Set unit of conversion</para>
                <para>note: only available for newly created or writable file</para>
            </summary>
            <param name="unit">[in] object of type IUnit, null to remove reference for unit.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cc_unit.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.SetPhysRange(System.Double,System.Double,System.Boolean)">
            <summary>
                <para>Set physical range</para>
                <para>note: only available for newly created conversion rule that is not assigned to any channel!</para>
To alter the physical range of a channel, consider using IChannel::SetPhysRange.
Set the minimum and maximum physical value that occurred for the signal.
For arrays, the minimum and maximum value is calculated over all elements.
<para>note: should only be set if this conversion rule is used for one channel only.</para></summary>
            <param name="minV">[in] min minimum physical value</param>
            <param name="maxV">[in] max maximum physical value</param>
            <param name="isValid">[in] isValid false if physical range is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.SetPrecision(System.Byte,System.Boolean)">
            <summary>
                <para>Set the precision to use for display of floating point values</para>
                <para>note: only available for newly created or writable file and not available for MDF3 (use IChannel::SetPrecision instead)</para>
            </summary>
            <param name="precision">[in] number of decimal places to use for display of floating point values or 255 (0xFF) in case of unrestricted precision</param>
            <param name="isValid">[in] false if precision is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of conversion</para>
                <para>note: only available for newly created or writable file and not available for MDF3</para>
            </summary>
            <param name="comment">[in] object of type IComment, null to remove reference to a comment object.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cc_comment.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToString(System.String,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given text value
</summary>
            <param name="rawValue">[in] text value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with result of conversion, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToString(System.Double,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given floating point value
</summary>
            <param name="rawValue">[in] value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with result of conversion, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToString(System.Int64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given integer value
</summary>
            <param name="rawValue">[in] value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with result of conversion, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToValue(System.String,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given text value
</summary>
            <param name="rawValue">[in] text value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>result of conversion, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToValue(System.Double,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given integer value
</summary>
            <param name="rawValue">[in] value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>result of conversion, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ConvertToValue(System.Int64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Convert the given floating point value
</summary>
            <param name="rawValue">[in] value to convert</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>result of conversion, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.ReadPhysRange(System.Double@,System.Double@)">
            <summary>
                <para>Read physical range</para>
                <para>The conversion can be used to store the minimum and maximum physical value that
occurred for a signal.</para>
                <para>For arrays, the minimum and maximum value is calculated over all elements.</para>
                <para>note: the range may not be valid</para>
            </summary>
            <param name="minV">[out] the minimum physical value of the range will be assigned</param>
            <param name="maxV">[out] the maximum physical value of the range will be assigned</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetPrecision">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetPrecision(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetPrecision(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Request the precision to use for display of floating point values
<para>note: the precision information is optional and not avialble for MDF3 (use IChannel::GetPrecision instead)</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>number of decimal places to use for display of floating point values or 255 (0xFF) in case of error or unrestricted precision</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetUnit">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetUnit(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetUnit(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get unit of conversion
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IUnit object, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetInverse">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetInverse(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetInverse(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get inverse conversion
<para>note: optional for MDF4, not available for MDF3 or for inverse conversion</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment of conversion
<para>note: optional for MDF4, not available for MDF3</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IConversion.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get name of conversion
<para>note: optional for MDF4, not available for MDF3</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with channel name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.HasStatusStringTable">
            <summary>
Request if conversion has a status string table
<para>note: for a status string table normally some raw values are reserved for exceptional states
while all other raw values are converted as usual.
For MDF3, a status string table may only appear in combination with a linear conversion.
For MDF4, it may be combined with any conversion.</para></summary>
            <returns>true if conversion has a status string table, otherwise false</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetResultType">
            <summary>
Get result type of the conversion
</summary>
            <returns>conversion result type, see ConversionResultType, eConversionResultTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetType">
            <summary>
Get type of the conversion
</summary>
            <returns>conversion type, see ConversionType, eConversionTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IConversion.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IConversion">
            <summary>
                <para>Conversion rule to convert a value</para>
                <para>The IConversion object specifies a conversion formula to convert a raw value to a physical value with a physical unit
or vice versa for an inverse conversion.</para>
                <para>The result of a conversion always is either a floating-point value (double) or a character string (text).</para>
                <para>A conversion may return always a double value, or always a string value, or the result type may depend on the input value
(partial conversion or conversion that has a status table).</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.GetOrCreateUnit(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.GetOrCreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.GetOrCreateUnit(System.String,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.GetOrCreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.GetOrCreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get a previously created or read unit object with the same text or create a new one if not found</para>
                <para>This can be used to "share" unit objects in MDF4. For MDF3 this is identical to CreateUnit().</para>
                <para>Note: only objects can be found that were created or read before!</para>
            </summary>
            <param name="text">
                <para>[in] text for unit.</para>
                <para>This can be a plain text or an XML fragment containing additional meta data, depending on parameter isXML.</para>
                <para>In case of an XML fragment it should be valid XML and match the schema for the designated parent object and the respective MDF version of the file.</para>
            </param>
            <param name="isXml">[in] if true, the given text is an XML fragment, otherwise plain text. Must be false for MDF 3.x.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IUnit object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateEcuSourceInfoMdf3(System.String,System.String,System.UInt16,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateEcuSourceInfoMdf3(System.String,System.String,System.UInt16,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateEcuSourceInfoMdf3(System.String,System.String,System.UInt16,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create source info object of type eSourceEcu for a channel (MDF3)
<para>note: only available for MDF3. For MDF4, use method IFactory::CreateSourceInfo.</para><para>The resulting ISourceInfo object can only be used for a channel.</para></summary>
            <param name="deviceName">[in] name of the device/ECU. Use null or empty string if unknown.
The length of the text is restricted (&lt; 32 chars). In case text is longer, it will be trunctated and the error code set to eStringTruncated.</param>
            <param name="description">[in] text for a description. Use null or empty string if unknown.
The length of the text is restricted (&lt; 80 chars). In case text is longer, it will be trunctated and the error code set to eStringTruncated.</param>
            <param name="moduleNumber">[in] number of the module, e.g. CCP station address. Use 0 if unknown.</param>
            <param name="address">[in] address of the module, usually unused. Use 0 if unknown.</param>
            <param name="errorCode">[out] returns the error code for the operation.</param>
            <returns>pointer to ISourceInfo object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateBusSourceInfoMdf3(System.UInt32,System.String,System.UInt32,System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateBusSourceInfoMdf3(System.UInt32,System.String,System.UInt32,System.String,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateBusSourceInfoMdf3(System.UInt32,System.String,System.UInt32,System.String,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create source info object of type eSourceBus for a channel (MDF3)
<para>note: only available for MDF3. For MDF4, use method IFactory::CreateSourceInfo.</para><para>The resulting ISourceInfo object can only be used for a channel.</para></summary>
            <param name="busChannelNumber">[in] 1-based bus channel number. Use 0 if unknown.</param>
            <param name="messageName">[in] numeric ID of the message. Use 0 if unknown.</param>
            <param name="messageID">[in] name of the message. Use null or empty string if unknown.
the length of the text is restricted (&lt; 36 chars). In case text is longer, it will be trunctated and the error code set to eStringTruncated.</param>
            <param name="description">[in] text for a description. Typically this is the network node name or the name of the sender. Use null or empty string if unknown.
the length of the text is restricted (&lt; 36 chars). In case text is longer, it will be trunctated and the error code set to eStringTruncated.</param>
            <param name="errorCode">[out] returns the error code for the operation.</param>
            <returns>pointer to ISourceInfo object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.ValueRange2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value range 2 text / scale conversion
<para>note: not available for MDF3</para></summary>
            <param name="valueRange2TextOrConversionArray">[in] array with pairs of key and either a text or a conversion. The array should be sorted according to key values (increasing).
Note: all conversion objects must be in the current file and number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] either a text or a conversion to use as default value. Can be null.
Note: in case of a conversion, the object must  be in the current file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null).</param>
            <param name="comment">[in] comment to add to the source info (can be null).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreatePartialConversion(Vector.Mdf4LibDotNet.Value2TextOrConversion[],System.ValueType!Vector.Mdf4LibDotNet.TextOrConversion!System.Runtime.CompilerServices.IsBoxed,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value 2 text / scale conversion
<para>note: not available for MDF3</para></summary>
            <param name="value2TextOrConversionArray">[in] array with pairs of key and a text or conversion. The array should be sorted according to key values (increasing).
Note: all conversion objects must be in current file and number of array elements (must be &gt; 0)</param>
            <param name="defaultValue">[in] either a text or a conversion to use as default value. Can be null.
Note: in case of a conversion, the object must be in current file</param>
            <param name="name">[in] pointer to text for name of conversion (can be null).</param>
            <param name="comment">[in] comment to add to the source info (can be null).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],Vector.Mdf4LibDotNet.IConversion)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create status string table conversion with value range 2 text status table
</summary>
            <param name="valueRange2TextArray">[in] array with key range-text pairs for status table. The array should be sorted according to key ranges (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="mainConversion">[in] pointer to main conversion (e.g. linear conversion).
Note: object must be in current file and must not be a status table conversion. For MDF 3.x, this must be a linear conversion.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.Value2Text[],Vector.Mdf4LibDotNet.IConversion)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.Value2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateStatusStringTableConversion(Vector.Mdf4LibDotNet.Value2Text[],Vector.Mdf4LibDotNet.IConversion,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create status string table conversion with value 2 text status table
</summary>
            <param name="value2TextArray">[in] array with key-text pairs for status string table. The array should be sorted according to key values (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="mainConversion">[in] pointer to main conversion (e.g. linear conversion).
Note: object must be in current file and must not be a status table conversion. For MDF 3.x, this must be a linear conversion.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2TextConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2TextConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2TextConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2TextConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2TextConversion(Vector.Mdf4LibDotNet.ValueRange2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value range 2 text conversion
</summary>
            <param name="valueRange2TextArray">[in] array with key range-text pairs. The array should be sorted according to key ranges (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] default value (text) to use (can be null)</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2ValueConversion(Vector.Mdf4LibDotNet.ValueRange2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2ValueConversion(Vector.Mdf4LibDotNet.ValueRange2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2ValueConversion(Vector.Mdf4LibDotNet.ValueRange2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2ValueConversion(Vector.Mdf4LibDotNet.ValueRange2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValueRange2ValueConversion(Vector.Mdf4LibDotNet.ValueRange2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value range 2 value conversion
<para>note: not available for MDF3</para></summary>
            <param name="valueRange2ValueArray">[in] array with key range-value pairs. The array should be sorted according to key ranges (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] default value to use</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null).</param>
            <param name="comment">[in] comment to add to the source info (can be null).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2TextConversion(Vector.Mdf4LibDotNet.Text2Text[],System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateText2TextConversion(Vector.Mdf4LibDotNet.Text2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2TextConversion(Vector.Mdf4LibDotNet.Text2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateText2TextConversion(Vector.Mdf4LibDotNet.Text2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2TextConversion(Vector.Mdf4LibDotNet.Text2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create text 2 text conversion
<para>note: not available for MDF3</para></summary>
            <param name="text2TextArray">[in] array with key-text pairs. Number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] default value (text) to use (can be null)</param>
            <param name="name">[in] pointer to text for name of conversion (can be null).</param>
            <param name="comment">[in] comment to add to the source info (can be null).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2ValueConversion(Vector.Mdf4LibDotNet.Text2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateText2ValueConversion(Vector.Mdf4LibDotNet.Text2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2ValueConversion(Vector.Mdf4LibDotNet.Text2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateText2ValueConversion(Vector.Mdf4LibDotNet.Text2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateText2ValueConversion(Vector.Mdf4LibDotNet.Text2Value[],System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create text 2 value conversion
<para>note: not available for MDF3</para></summary>
            <param name="text2ValueArray">[in] array with text-value pairs. Number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] default value to use</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null).</param>
            <param name="comment">[in] comment to add to the source info (can be null).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2TextConversion(Vector.Mdf4LibDotNet.Value2Text[],System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2TextConversion(Vector.Mdf4LibDotNet.Value2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2TextConversion(Vector.Mdf4LibDotNet.Value2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2TextConversion(Vector.Mdf4LibDotNet.Value2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2TextConversion(Vector.Mdf4LibDotNet.Value2Text[],System.String,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value 2 text conversion
</summary>
            <param name="value2TextArray">[in] array with key-text pairs. The array should be sorted according to key values (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="defaultValue">[in] default value (text) to use (can be null, not available for MDF 3.x).</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2ValueConversion(Vector.Mdf4LibDotNet.Value2Value[],System.Boolean,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2ValueConversion(Vector.Mdf4LibDotNet.Value2Value[],System.Boolean,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2ValueConversion(Vector.Mdf4LibDotNet.Value2Value[],System.Boolean,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2ValueConversion(Vector.Mdf4LibDotNet.Value2Value[],System.Boolean,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateValue2ValueConversion(Vector.Mdf4LibDotNet.Value2Value[],System.Boolean,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create value 2 value conversion
</summary>
            <param name="value2ValueArray">[in] array with key-value pairs. The array should be sorted according to key values (increasing). Number of array elements (must be &gt; 0).</param>
            <param name="interpolate">[in] interpolate if true, a value2value conversion with interpolation is created, otherwise without</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.SyntaxVersion,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.SyntaxVersion,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.SyntaxVersion,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create algebraic conversion
In contrast to CreateAlgebraicConversion(), here the syntax version of the formula text can be specified.
In case it does not match the syntax required for the current MDF version, the method tries to transform the formula to the required syntax.
In any case, the formula will be parsed and checked for syntax errors (CreateAlgebraicConversion() does not check the syntax).
</summary>
            <param name="formulaText">[in] pointer to text for formula</param>
            <param name="syntaxVersion">[in] specifies the syntax version of the given formula text, see SyntaxVersion</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateAlgebraicConversion(System.String,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create algebraic conversion
</summary>
            <param name="formulaText">[in] pointer to text for formula. The formula must be valid for the current MDF version.
            Otherwise, please use overloaded method where the syntax version of the given formula text can be specified.
</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateRationalConversion(System.Double[],Vector.Mdf4LibDotNet.ConversionType,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create rational conversion
</summary>
            <param name="parameterArray">[in] array with factors for rational conversion.
for type = eRational and ePolynomial exactly 6 parameters are required.
for type = eExponential and eLogarithmic exactly 7 parameters are required.
for type = eLinear exactly 2 parameters are required (same as when using CreateLinearConversion() with offset = parameterArray[0] and factor = parameterArray[1])

Please refer to MDF specification for exact parameter definition of the respective conversion type.</param>
            <param name="type">[in] specifies the type of algebraic conversion to create (default: eRational).
for MDF 4.x this can only be eRational.
for MDF 3.x in addition ePolynomial, eExponential, and eLogarithmic are allowed.</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateLinearConversion(System.Double,System.Double,Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create linear conversion f(x) = A ^ x + B
</summary>
            <param name="factor">[in] factor A for linear conversion</param>
            <param name="offset">[in] offset B for linear conversion</param>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateIdentityConversion">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateIdentityConversion(Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateIdentityConversion(Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateIdentityConversion(Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateIdentityConversion(Vector.Mdf4LibDotNet.IUnit,System.String,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create identity conversion f(x) = x
</summary>
            <param name="unit">[in] unit for the conversion, null if no unit should be used.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_unit.xsd for the respective MDF version of the file.</param>
            <param name="name">[in] pointer to text for name of conversion (can be null, ignored for MDF 3.x).</param>
            <param name="comment">[in] comment to add to the source info (can be null, ignored for MDF 3.x).
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema cc_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateSourceInfo(System.String,System.String,Vector.Mdf4LibDotNet.SourceType,Vector.Mdf4LibDotNet.SourceBusType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateSourceInfo(System.String,System.String,Vector.Mdf4LibDotNet.SourceType,Vector.Mdf4LibDotNet.SourceBusType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateSourceInfo(System.String,System.String,Vector.Mdf4LibDotNet.SourceType,Vector.Mdf4LibDotNet.SourceBusType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create source info object
<para>note: only available for MDF4. For MDF3, use the special methods IFactory::CreateBusSourceInfoMdf3 or IFactory::CreateEcuSourceInfoMdf3.
The resulting ISourceInfo object may be used either for a channel or for a channel group.</para></summary>
            <param name="name">[in] pointer to text for name of source</param>
            <param name="path">[in] pointer to text for path of source</param>
            <param name="type">[in] type of source, see SourceType</param>
            <param name="busType">[in] type of bus in case source type = eSourceBus</param>
            <param name="comment">[in] comment to add to the source info.
This can be a plain text or an XML fragment containing additional meta data.
In case of an XML fragment it should be valid XML and match the schema si_comment.xsd for the respective MDF version of the file.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to ISourceInfo object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateUnit(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateUnit(System.String,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IFactory.CreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateUnit(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create unit object
</summary>
            <param name="text">[in] pointer to text for unit.
This can be a plain text or an XML fragment containing additional meta data, depending on parameter isXML.
In case of an XML fragment it should be valid XML and match the schema for the designated parent object and the respective MDF version of the file.
For MDF3, the length of the unit text is restricted (&lt; 20 chars). In case text is longer, it will be trunctated and the error code set to eStringTruncated.</param>
            <param name="isXml">[in] if true, the given text is an XML fragment, otherwise plain text. Must be false for MDF 3.x. Default: false</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IUnit object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateComment(System.String,System.Boolean,Vector.Mdf4LibDotNet.CommentParentType,Vector.Mdf4LibDotNet.FieldProperties[],System.String,Vector.Mdf4LibDotNet.CommentMergeFlags)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateComment(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@,Vector.Mdf4LibDotNet.CommentParentType,Vector.Mdf4LibDotNet.FieldProperties[],System.String,Vector.Mdf4LibDotNet.CommentMergeFlags)">
            <summary>
Create comment object and optionally add/update/remove comment fields.

This method can be used to
<ul><li>create a new comment, or</li><li>to clone a comment from the same or another file by appending/replacing/removing the comment text and/or comment fields.
    See options parameter for details on how to merge the comment information.
    Don't forget to set ::eUpdateCreatorInformation in case the comment originates from another file.</li></ul>
For file comments, consider using IFile::SetCommentTextAndFields instead.
This method offers also to set standard comment fields which, for MDF 3.x, are not encoded in the comment text.

Example for adding/updating a comment field for an existing channel comment or to create a new comment, in case there is no comment present before.
<code>
// C#
var newFields = new[]
{
  new FieldProperties("field 1", "value 1"),
  new FieldProperties("field 2", "2016-01-25", null, "this is a description", null, FieldDataType.eFieldDataTypeDate),
  new FieldProperties("field 3", new[] {"1", "2", "3"}, "pieces", null, null, FieldDataType.eFieldDataTypeInteger)
};
IComment comment = channel.GetComment();
if (comment != null)
{
  bool isXml = comment.IsXml();
  String oldText = isXml ? comment.GetXml() : comment.GetText();
  comment = factory.CreateComment(oldText, isXml, null, CommentParentType.eCommentParentChannel, newFields);
}
else
{
  // create a new comment with empty text and the comment field
  comment = factory.CreateCommentEx(null, false, null, CommentParentType.eCommentParentChannel, newFields);
}
// set the newly created comment
channel.SetComment(comment);
</code></summary>
            <param name="text">[in] text pointer to text for comment; can be null (treated equal to empty text).
            This can be a plain text or text with encoded information, e.g. from an existing comment.
            This text will be updated or merged, depending on the options and the other parameters.
            For MDF 4.x encoded information requires an XML fragment (parameter isXml = true),
            whereas for MDF 3.x also non-XML text may contain encoded information.
            In case of an XML fragment it should be valid XML and match the schema for the designated parent object
            and the respective MDF version of the file.</param>
            <param name="isXml">[in] if true, the given text is an XML fragment, otherwise plain text. Must be false for MDF 3.x.</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <param name="parentType">[in] type of parent object the comment should be assigned to. See CommentParentType.
            Only relevant for MDF 4.x in case comment fields must be encoded, otherwise it can be set to ::eCommentParentTypeUnspec.
            Note: when creating a file comment for MDF 3.x, please specify ::eCommentParentFile to avoid using reserved field names for standard fields.
            Or, better, use IFile::SetCommentTextAndFields.</param>
            <param name="commentFields">[in] array with comment fields and their properties; can be null if no list is specified.</param>
            <param name="plainText">[in] plain comment text to set (i.e. in &lt;TX&gt; tag for MDF 4.x); can be null to keep the original text.
            See CommentMergeFlags for further details.</param>
            <param name="options">[in] bit flags for merging existing information with new information, see CommentMergeFlags.
            Attributes in MDF4 are only replaced for an already existing field if the attribute value is not null (for unit, desc, lang)
            or ::eFieldDataTypeUnspec (for type).
            Note: In MDF 4.x, existing fields are only possible if isXml is true.</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateComment(System.String)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateComment(System.String,System.Boolean)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.CreateComment(System.String,System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create comment object
</summary>
            <param name="text">[in] pointer to text for comment.
This can be a plain text or an XML fragment containing additional meta data, depending on parameter isXML.
In case of an XML fragment it should be valid XML and match the schema for the designated parent object and the respective MDF version of the file.</param>
            <param name="isXml">[in] if true, the given text is an XML fragment, otherwise plain text. Must be false for MDF 3.x. Default: false</param>
            <param name="errorCode">[out] returns the error code for the operation</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IFactory.GetFile">
            <summary>
Get reference to parent file
</summary>
            <returns>pointer to IFile object, null on error</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IFactory">
            <summary>
                <para>Factory object for creation of sharable objects in the file.</para>

The IFactory object serves to create new "sharable" objects.
Sharable objects are objects that may be used by several other objects.

<para>The following objects are sharable:</para><para>IComment</para><para>IUnit</para><para>IConversion</para><para>ISourceInfo</para><para>After creation of the sharable object, the object must be assigned to some other object in the file.</para>
This can be done using one of the Set methods (e.g. IFile::SetComment) or in one of the other creation methods (e.g. IFile::CreateChannelGroup).

Access to the IFactory object is provided by IFile::GetFactory.
It is only available for newly created files (with IFileMananger::CreateFile) or
for files opened for modification (see IFileMananger::OpenFile).
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNodeSet.GetNodeByIndex(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNodeSet.GetNodeByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNodeSet.GetNodeByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get object from set for given index
</summary>
            <param name="index"> index of element</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to ICommentNode object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNodeSet.GetCount">
            <summary>
Get number of objects in set
</summary>
            <returns> number of comment nodes, 0 if empty or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNodeSet.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ICommentNodeSet">
            <summary>
                <para>Collection of ICommentNode objects</para>
                <para>
The ICommentNodeSet object contains a number of comment nodes (see ICommentNode).
It can be used to filter comment nodes associated to a comment or a parent node.
</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.AsArrayOfStructs">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentFieldSet.AsArrayOfStructs(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.AsArrayOfStructs(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get all objects from set as array of structs (see FieldProperties)
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to array of FieldProperties objects, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.GetFieldByIndex(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentFieldSet.GetFieldByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.GetFieldByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get object from set for given index
</summary>
            <param name="index"> index of element</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to ICommentField object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.GetCount">
            <summary>
Get number of objects in set
</summary>
            <returns> number of comment fields, 0 if empty or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentFieldSet.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ICommentFieldSet">
            <summary>
                <para>Collection of ICommentField objects</para>
                <para>
The ICommentFieldSet object contains a number of comment fields  (see ICommentField).
It can be used to filter comment fields associated to a comment or a comment node.
</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetCommentFieldSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get set for comment fields of the node
</summary>
            <param name="filterFlags"> flags for filtering, value is a bit combination of ::CommentFieldFilterFlags</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to ICommentFieldSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetParentNode">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetParentNode(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetParentNode(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get parent node of the node
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to ICommentNode object, null on error or for root nodes</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetCreatorInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get information about creator of node.
</summary>
            <para>Note:  Optional, not available for root nodes (see GetType()).
See IFile::GetCreatorInfo(), IFile::GetFileHistoryLog()</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to ICreatorInfo object, null on error or for MDF version &lt; 4.0.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetLanguage">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetLanguage(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetLanguage(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get language of node.
</summary>
            <para>Note:  Optional, not available for root nodes (see GetType()).
The language is returned as string as defined in XML standard.
Example: "en-US" = English as used in the United States.</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with language of node, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetDescription">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get description of node.
</summary>
            <para>Note:  Optional, not available for root nodes and list items (see GetType()).</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with description for node, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetType">
            <summary>
Get type of node.
</summary>
            <returns> event type, see ::CommentNodeType, ::eCommentNodeTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentNode.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get name of node.
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with node name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentNode.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ICommentNode">
            <summary>
                <para>Description of a node in hierarchy of comment fields</para>
                <para>
The ICommentNode object describes a node for a comment field hierarchy (tree/list).
<ul><li>For MDF 4.x, the &lt;common_properties&gt; tag in XML may define a list of comment fields
(&lt;e&gt; tag for single key-value pair or &lt;elist&gt; tag for a field with multiple values)
or also a hierarchical structure of these fields (&lt;tree&gt; and &lt;list&gt; tags).</li><li>For MDF 3.x, there can be only a flat list of comment fields (Vector proprietary extension).</li></ul>
For both cases, a "root" node is modeled for the flat list of comment fields (ICommentField objects).
</para>
                <para>Note:  &lt;list&gt; and &lt;elist&gt; tags are only available in MDF 4.1 or higher.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.ToStruct">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.ToStruct(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.ToStruct(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get information of comment field as struct.

Can be used to copy comment fields, see IFile::SetCommentTextAndFields and IFactory::CreateCommentEx.
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> property struct with information about the comment field. Missing properties are set to default values.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetCreatorInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt64)">
            <summary>
Get information about creator of comment field.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0.
See IFile::GetCreatorInfo(), IFile::GetFileHistoryLog()</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <param name="index">if &lt; 0, information about the creator of the field is returned,
                   otherwise about the creator of the field value
                   (identical to the field creator for standard &lt;e&gt; tag, can be different for a list of values in &lt;elist&gt; tag)</param>
            <returns> pointer to ICreatorInfo object, null on error or for MDF version &lt; 4.0.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.IsReadOnly">
            <summary>
Check if field is marked as read-only.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0. If not specified, the field is considred not to be read-only.</para>
            <returns> true if this field is marked as read-only, false otherwise.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetDataType">
            <summary>
Get data type of field value.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0. If not specified, ::eFieldDataTypeString is used.</para>
            <returns> event type, see ::FieldDataType, ::eFieldDataTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetLanguage">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetLanguage(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetLanguage(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get language of field.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0.
The language is returned as string as defined in XML standard.
Example: "en-US" = English as used in the United States.</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with language of field, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetDescription">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get description of field.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0.</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with description for field, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetUnit">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetUnit(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetUnit(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get unit of field.
</summary>
            <para>Note:  Optional, only available for MDF version &gt;= 4.0.</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with unit for field, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValues">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetValues(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValues(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get all values of field as array of texts
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to array of strings with field values, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValue">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValue(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValue(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get value of field as text for given index.
</summary>
            <param name="index"> index of value, can be &gt; 0 for a multi-value field (&lt;elist&gt; in MDF 4.1 or hither). Default: 0. See GetValueCount()</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with field value, null on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValueCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetValueCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetValueCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get number of values for this field
</summary>
            <para>Note:  MDF 4.1 or higher allows a list of values (using an &lt;elist&gt; tag).
For MDF 4.0 there can be only one value.</para>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> Number of values for this field, 0 on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetType">
            <summary>
Get type of field.
</summary>
            <returns> field type, see ::CommentFieldType, ::eCommentFieldTypeUnspec on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.ICommentField.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get name of field.
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to string with field name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ICommentField.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ICommentField">
            <summary>
                <para>Description of a comment field</para>
                <para>The ICommentField object describes a custom field of a comment.
<ul><li>For MDF 4.x, these are &lt;e&gt; or &lt;elist&gt; tags in XML comment (below &lt;common_properties&gt; tag).</li><li>For MDF 3.x comment fields are encoded in a proprietary format in the text comment.</li></ul></para>
                <para>Note:
&lt;elist&gt; tags are only available in MDF 4.1 or higher. They are similar to &lt;e&gt; tags, but can store a list of values.
</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetCommentFieldSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetCommentFieldSet(Vector.Mdf4LibDotNet.CommentFieldFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment fields encoded in IComment object
</summary>
            <param name="filterFlags"> flags for filtering, value is a bit combination of CommentFieldFilterFlags</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to ICommentFieldSet object, null on error or if no comment fields are available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetParentType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetParentType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetParentType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get type of parent object of the comment
<para>Note:  only available for MDF 4.x in case of XML comments. The parent type is determined from the root XML tag. </para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>event type, see CommentParentType, CommentParentType::eCommentParentTypeUnspec on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetPlainText">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetPlainText(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetPlainText(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get plain text of comment after removing encoded comment fields
and other Vector specific insertions in MDF 3.x
<para>Note:  for MDF 4.x this is identical to GetText() </para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to text, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetXml">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetXml(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetXml(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get plain XML string (only if IsXml() is true)</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to XML string, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.IsXml">
            <summary>
                <para>Request if comment is XML string</para>
            </summary>
            <returns> true if comment is XML string (MDBLOCK in MDF4 only)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetText">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IComment.GetText(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetText(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get main text of comment (contents of TXBLOCK or contents of &lt;TX&gt; tag for MDBLOCK)</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns> pointer to text, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IComment.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IComment">
            <summary>
                <para>Comment of some other object</para>
                <para>The IComment object contains the comment text of some other object.
It can be a plain text or (for MDF4) also an XML fragment.</para>
                <para>Apart from a plain text, each comment may contain additional information encoded in XML (MDF 4.x) or in a Vector proprietary encoding (MDF 3.x).
This information may contain so-called "Comment fields" which are the most common way to store custom information in MDF that is generally readable.
Comment fields store custom information as key-value pairs. MDF 4.x even offers hierarchical structure of these fields using tree or list nodes (MDF 4.x).
<ul><li>In MDF4 Lib, comment fields are modelled by ICommentField objects that can be accessed via IComment::GetCommentFieldSet().</li><li>In order to create IComment objects with comment fields, either use IFactory::CreateCommentEx() or (only for file comment) IFile::SetCommentTextAndFields.</li></ul></para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String,Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String,Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String,Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String,Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelSubSet(System.String,System.String,Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get a sub set with all channels matching the given parameters
</summary>
            <param name="channelName">[in] name of channel to find.
If the eUseChannelNameAsMask bit is set in filterFlags, the string is a search mask with wild cards.
The wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.</param>
            <param name="extendedNamePrefix">[in] if given, the extended name prefix also must match (see IChannel::GetExtendedNamePrefix). Default: null.
If the eUseNamePrefixAsMask bit is set in filterFlags, the string is a search mask with wild cards.
Like for channelName, the wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.
If the eAcceptIfNoExtension bit is set in options, channels without an extended name prefix are accepted.</param>
            <param name="subSetFilterFlags">[in] flags for filtering default is eSubSetFilterFlagsUnspecified, value is a bit combination of ::ChannelSubSetFilterFlags. Default: eSubSetFilterFlagsUnspecified</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> IChannelSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByName(System.String)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByName(System.String,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByName(System.String,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get first channel from set that matches the given name.</para>
                <para>Note: this method uses case-sensitive comparison. For case-insensitive comparison use GetChannelSubSet() with flag ::eCompareNoCase.
<br />If ::eUseBinarySearchForChannelName has been specified for Get(Child)ChannelSet method (or ::eUseBinarySearchForResultSet for GetChannelSubSet()),
this method uses a binary search to find the channel name. In this case the first call to GetChannelName() takes longer
because all channels first must be sorted according to their names.
If there are several channel with equal name, the binary search will find one of them but not necessarily the first one.</para>
            </summary>
            <param name="channelName">channelName name of channel to find.</param>
            <param name="errorCode">error code of the operation will be returned.</param>
            <returns>return pointer to IChannel object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByIndex(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetChannelByIndex(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get channel from set for given index.</para>
            </summary>
            <param name="index">index of element.</param>
            <param name="errorCode">error code of the operation will be returned.</param>
            <returns>return pointer to IChannel object, null if no channel found or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelSet.GetCount">
            <summary>
Get number of channels in set
</summary>
            <returns>return number of channels, 0 if empty or on error</returns>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IChannelSet">
            <summary>
                <para>Collection of channels</para>
                <para>The IChannelSet object contains a number of channels.</para>
                <para>It can be used to filter channels from a file, a channel group, or from the children of a channel (i.e. structure members or array elements).</para>
                <para>The channels can be accessed by zero-based index in the set or by name.</para>
                <para>A further method filters the channels from the set into a new subset.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetParentDataGroupStartAddress">
            <summary>
Get start addresses of parent DG block
</summary>
            <returns>start address of parent DG block for this channel group, -1 on error or for virtual channel groups.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetBlockStartAddress">
            <summary>
Get start addresses of CG block
</summary>
            <returns>start address of CG block for this channel group, -1 on error or for virtual channel groups.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get event set for events for this channel group.
Note: The resulting IEventSet object offers further filtering of the events.
</summary>
            <param name="filterFlags">[in] flags for filtering, value is a bit combination of EventFilterFlags</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IEventSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Create a data pointer object to navigate and read signal data
</summary>
            <param name="flags">[in] bit combination of option flags, see DataPointerOptionsFlags. Default: eUseReadBuffer</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetBusEventType(Vector.Mdf4LibDotNet.BusEventType)">
            <summary>
                <para>Change the type of bus event contained in the channel group</para>
                <para>Usually the bus event type is set automatically when creating the respective channels in the channel group.</para>
                <para>For rare cases, however, it may be necessary to manually change the bus event type of the channel group.</para>
                <para>note: only available for newly created or writable file, not available for MDF &lt; 4.1.</para>
            </summary>
            <param name="busEventType">[in] of the contained bus event (see BusEventType).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetAcquisitionName(System.String)">
            <summary>
                <para>Set the acquisition name for this channel group</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="acquisitionName">[in] string to be used as acquisition name, 0 or empty to delete the name</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetPathSeparatorChar(System.UInt16)">
            <summary>
                <para>Set the path separator for this channel group</para>
                <para>note: optional feature, only available for newly created or writable file, not available for MDF &lt; 4.1.</para>
            </summary>
            <param name="pathSeparatorChar">[in] character to be used as path separator, 0 if path separator is not defined</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetPathSeparatorChar">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetPathSeparatorChar(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetPathSeparatorChar(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the path separator specified for this channel group as character</para>
                <para>note: optional feature available for MDF &gt;= 4.1</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the character to be used as path separator, 0 on error or if not available/not defined</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,Vector.Mdf4LibDotNet.ZipTypeAndLevel)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(Vector.Mdf4LibDotNet.ZipTypeAndLevel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,Vector.Mdf4LibDotNet.ZipTypeAndLevel)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(System.UInt32,Vector.Mdf4LibDotNet.ZipTypeAndLevel)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,Vector.Mdf4LibDotNet.ZipTypeAndLevel)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataWriter(Vector.Mdf4LibDotNet.ErrorCode@,System.UInt32,Vector.Mdf4LibDotNet.ZipTypeAndLevel)">
            <summary>
                <para>Create a data writer object to write signal values for this channel group</para>
                <para>note: for MDF3, any other operation that creates a new object and writes it to file (e.g. IFacotry::CreateComment or IFile::CreateChannelGroup) is only allowed after the IDataWriter has been released!</para>
                <para>Only one IDataWriter can be open per file, i.e. creating a new IDataWriter will fail as long as another one is open and has not been released yet.</para>
                <para>It is also not allowed to create an IDataWriter as long as there is an open data pointer (IDataPointer/IGroupDataPointer) using this channel group.</para>
            </summary>
            <param name="errorCode">[out] returns the error code for the operation. Default: null</param>
            <param name="recordCountForWriteBuffer">[in] number of records to store in internal write buffer before flushing to file (MDF4 only, will be ignored for MDF3).
If 0, the number of records to buffer will be determined internally (default)
If 1, each single record will be written to file immediately (bad performance, should only be used for large or VLSD records).</param>
            <param name="zipTypeAndLevel">[in] type and level of compression algorithm to use, see ZipTypeAndLevel. Must be eNoCompression for MDF &lt; 4.1.</param>
            <returns>on success the IDataWriter interface of the created data writer, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateStreamSyncChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IAttachment,Vector.Mdf4LibDotNet.SyncType,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a stream synchronization channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.
For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel.
Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="name">[in] name for the channel.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="streamAttachment">[in] pointer to IAttachment object with stream to be synchronized (must not be null).
Note: attachment object must be in same file and in global list of attachments.</param>
            <param name="syncType">[in] type of synchronization with the stream in attachment, see SyncType. Only values eTimeSync, eAngleSync, eDistanceSync, and eIndexSync are allowed.
Note: Physical values of this channel must return the unit of the respective synchronization domain,
i.e. seconds for syncType = eTimeSync, or an index value for syncType = eIndexSync.
These values are used for synchronization with the stream.</param>
            <param name="bitCount">[in] number of bits used for the channel value in the record data bytes. Default is 32.</param>
            <param name="dataType">[in] data type of the channel (default = eInteger_Unsigned_LE), see ChannelDataType. For this channel type, only numeric data types are allowed.
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] pointer to IUnit object to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] pointer to IConversion object to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="channelSource">[in] pointer to ISourceInfo object to set for the channel.
Note: object must be in same file.</param>
            <param name="flags">[in] bit flags to set for the channel, see ChannelFlags.
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a maximum length data channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.
For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel.
Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="name">[in] name for the channel.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="sizeChannel">[in] pointer to IChannel object for the size signal of the MLSD channel.
Note: object must be in same file and channel group and should return as physical values only integer values &lt;= maxByteCount.</param>
            <param name="maxByteCount">[in] maximum number of Bytes for MLSD channel value, i.e. number of Bytes used for the channel value in the record data bytes.</param>
            <param name="dataType">[in] data type of the channel, see ChannelDataType. Default is eByteArray,
Typically only string or complex data types are used for MLSD channels.
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] pointer to IUnit object to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] pointer to IConversion object to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="channelSource">[in] channelSource pointer to ISourceInfo object to set for the channel.
Note: object must be in same file.</param>
            <param name="flags">[in] bit flags to set for the channel, see ChannelFlags.
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags. Default is 0.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a variable length data channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.
For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel (here 8 Bytes always).
Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="name">[in] name for the channel.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="channelDataType">[in] data type of the channel, see ChannelDataType. Default is eByteArray,
For VLSD channels, the data type specifies the type of the VLSD values. Typically only string or complex data types are used for VLSD channels.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] pointer to IUnit object to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] pointer to IConversion object to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="channelSource">[in] pointer to ISourceInfo object to set for the channel.
Note: object must be in same file.</param>
            <param name="flags">[in] bit flags to set for the channel, see ChannelFlags.
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags. Default is 0.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a fixed length data channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.
For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel.
Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="name">[in] name for the channel.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="bitCount">[in] number of bits used for the channel value in the record data bytes. Default 64,
if 0, a virtual data channel will be created (MDF 4.1)</param>
            <param name="dataType">[in] data type of the channel, see ChannelDataType. Default eReal_LE,
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] pointer to IUnit object to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] pointer to IConversion object to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="channelSource">[in] pointer to ISourceInfo object to set for the channel.
Note: object must be in same file.</param>
            <param name="flags">[in] bit flags to set for the channel, see ChannelFlags.
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags.</param>
            <param name="bitOffset">[in] bit offset of the channel value in the data bytes of the parent channel. 0-7, must be 0 for all data types &gt;= eReal_LE.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMasterChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMasterChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ISourceInfo,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a master channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>note: There can be at most one master channel (real or virtual) per sync type per channel group.
Adding a second master channel with the same sync type will fail with error code eNoUniqueMasterChannel.
For the created master channel automatically a IUnit will be added with name "s", "m" or "rad", depending on the sync type.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.
For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel.
Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="name">[in] name for the master channel.
If null, depending on the sync type automatically the name "time", "angle" or "distance" will be set.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="bitCount">[in] number of bits used for the channel value in the record data bytes.
if 0, a virtual master channel will be created.</param>
            <param name="dataType">[in] data type of the channel, see ChannelDataType. For this channel type, only numeric data types are allowed.
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="syncType">[in] synchronization type (default = eTimeSync) of the master channel, see SyncType. Only values eTimeSync, eAngleSync, and eDistanceSync are allowed.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] pointer to IUnit object to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] pointer to IConversion object to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="channelSource">[in] channelSource pointer to ISourceInfo object to set for the channel.
Note: object must be in same file.</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMasterChannel(System.String)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMasterChannel(System.String,System.UInt32,System.Double,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType)">
            <summary>For details please refer to respective overloaded method</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateMasterChannel(System.String,System.UInt32,System.Double,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a master channel in this channel group</para>
                <para>The given channel will be appended to the channel list of this channel group.</para>
                <para>note: There can be at most one master channel (real or virtual) per sync type per channel group.
Adding a second master channel with the same sync type will fail with error code eNoUniqueMasterChannel.
For the created master channel automatically a IUnit will be added with name "s", "m" or "rad", depending on the sync type.</para>
                <para>Please pay attention that the added channel can be identified uniquely within the channel group, otherwise the method might fail with eNoUniqueIdentification.</para>
                <para>For MDF4 the combination of channel name (cn), source name (cs) and source path (cp) (see GetSourceInfo) must be unique.</para>
                <para>Adding a channel, the range of data Bytes and possibly invalidation Bytes (MDF4) will be extended considering the range of Bytes used by the added channel.</para>
                <para>Hence, adding a channel that exceeds the current record length of the channel group is only possible as long as the channel group has no records (GetSampleCount() must be 0) and
no IDataWriter for the channel group is open.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="name">[in] name for the master channel.
If null, depending on the sync type automatically the name "time", "angle" or "distance" will be set.</param>
            <param name="byteOffset">[in] byte offset of the channel value in the record data bytes.</param>
            <param name="conversionFactor">[in] factor for a linear conversion (offset 0) of the master channel. Must be &gt;= 0, default = 1.0
If conversionFactor is different to 1, the method automatically creates or assigns a respective IConversion.</param>
            <param name="bitCount">[in] number of bits used for the channel value in the record data bytes. Default is 64.
if 0, a virtual master channel will be created.</param>
            <param name="dataType">[in] data type of the channel (default = eReal_LE), see ChannelDataType. For this channel type, only numeric data types are allowed.
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="syncType">[in] synchronization type (default = eTimeSync) of the master channel, see SyncType. Only values eTimeSync, eAngleSync, and eDistanceSync are allowed.</param>
            <param name="comment">[in] pointer to IComment object to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetSourceInfo(Vector.Mdf4LibDotNet.ISourceInfo)">
            <summary>
                <para>Set (acquisition) source information of channel group</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="sourceInfo">[in] pointer to ISourceInfo object, null to remove reference to a source info object.
Note: object must be in same file.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetDataGroupComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of parent data group</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="comment">[in] pointer to IComment object, null to remove reference to a comment object.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (dg_comment.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of channel group</para>
                <para>note: only available for newly created or writable file</para>
            </summary>
            <param name="comment">[in] pointer to IComment object, null to remove reference to a comment object.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cg_comment.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetBusEventType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetBusEventType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetBusEventType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the type of bus event contained in the channel group</para>
                <para>note: for MDF version &gt;= 4.1 only flags are checked, for earlier versions this is not supported yet.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>type of the contained bus event (see BusEventType), or eBusEventUnspec in case of an error or if not supported.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.ContainsBusEvent">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.ContainsBusEvent(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.ContainsBusEvent(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Check if channel group contains a bus event (bus logging for MDF 4.1)</para>
                <para>note: for MDF version &gt;= 4.1 only a flag is checked, for earlier versions this is not supported</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>true if the channel group contains a bus event, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointer">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.CreateDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a data pointer object to navigate and read signal data</para>
                <para>note: the extended method IChannelGroup::CreateDataPointerEx allows to specifiy options for the created IDataPointer</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.IsSorted">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.IsSorted(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.IsSorted(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Check if parent data group is sorted, i.e. data block cannot contain records of other channel groups
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>true if sorted, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get channel set of channel group
</summary>
            <param name="filterFlags">[in] flags for filtering, value is a bit combination of ChannelFilterFlags</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IChannelSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetMasterChannel">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetMasterChannel(Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetMasterChannel(Vector.Mdf4LibDotNet.SyncType)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetMasterChannel(Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetMasterChannel(Vector.Mdf4LibDotNet.SyncType,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get master channel of channel group for specified sync type
</summary>
            <param name="masterSyncType">[in] masterSyncType sync type of master channel (usually eTimeSync). Default: eTimeSync</param>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IChannel object, null on error or if requested master channel type is not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetSourceInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetSourceInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetSourceInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get source information of channel group
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to ISourceInfo object, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetAcquisitionName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetAcquisitionName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetAcquisitionName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get acquisition name
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with acquisition name, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetDataGroupComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetDataGroupComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetDataGroupComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment of parent data group
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment of channel group
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetInvalByteCount">
            <summary>
                <para>Get number of invalidation bytes in record</para>
                <para>note: invalidation bytes are optional and are not available for MDF3</para>
            </summary>
            <returns>number of invalidation bytes, 0 on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetDataByteCount">
            <summary>
                <para>Get number of data bytes in record</para>
                <para>note: this does not contain the bytes for the record ID nor invalidation bytes</para>
                <para>see: <see cref="M:Vector.Mdf4LibDotNet.IChannelGroup.GetInvalByteCount" /></para>
            </summary>
            <returns>number of data bytes, 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetSampleCount">
            <summary>
Get number of samples
</summary>
            <returns>number of samples, 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetFile">
            <summary>
Get reference to parent file
</summary>
            <returns>pointer to IFile object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannelGroup.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IChannelGroup">
            <summary>
                <para>Description of a channel group</para>
                <para>The IChannelGroup object describes a channel group (CG block) and also holds some information of the data group (DG block).</para>
                <para>A channel group contains a collection of channels which are stored in one record, i.e. which have equal sampling.</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetBlockStartAddress">
            <summary>
Get start addresses of CN block
</summary>
            <returns> start address of CN block for this channel (for arrays the template CN), -1 on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetName(System.String)">
            <summary>
                <para>Set/change the name of the channel.</para>
                <para>Note: only available for newly created or writable file, not available for array child channels in MDF4 files.</para>
                <para>Typically the name of a channel is fixed.</para>
                <para>For a possible use case for changing the name consider that the channel contains wrong signal
values that should be corrected. If this cannot be achieved simply by assigning a new conversion rule
(e.g. linear or value2value conversion), then a possible solution might be to rename the channel and
to create a new channel (in a new channel group) with the original channel name and with corrected values.</para>
                <para>Currently this requires duplication of all master channels in the new channel group, in a future MDF version
there might be an alternative solution by only referencing the original channel group.</para>
            </summary>
            <param name="name">[in] string to be used as name (must not be empty!).</param>
            <returns>error code for the operation.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetEventSet(Vector.Mdf4LibDotNet.EventFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get event set for events for this channel
Note: The resulting IEventSet object offers further filtering of the events.
</summary>
            <param name="filterFlags">[in] filterFlags flags for filtering, value is a bit combination of EventFilterFlags</param>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns> pointer to IEventSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetArrayInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetArrayInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetArrayInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get information about an array channel
note: Only available for array channels
</summary>
            <param name="errorCode">[out] error code of the operation will be returned</param>
            <returns>on success an IArrayInfo interface with information about the array is returned, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ConvertToArray(System.UInt16,System.UInt64[])">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.ConvertToArray(System.UInt16,System.UInt64[],Vector.Mdf4LibDotNet.ArrayType,Vector.Mdf4LibDotNet.ArrayPropertyFlags,System.Int32,System.UInt32)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ConvertToArray(System.UInt16,System.UInt64[],Vector.Mdf4LibDotNet.ArrayType,Vector.Mdf4LibDotNet.ArrayPropertyFlags,System.Int32,System.UInt32)">
            <summary>
Convert this channel to an array of channels
note: only available for newly created or writable file and for fixed-length value channels (channel type ::eFixedLength).
Currently not available for MDF 3.x and for array or structure child channels or structures or arrays.
The current channel will be used as "template" for creating an array of channels where each element channel
has the same properties except that the byte offset and (if used) the invalidation bit position varies.
The composition type of the parent channel will be changed to ::eIsArray.
</summary>
            <param name="dimCount">[in] number of dimensions for the array (must be &gt; 0)</param>
            <param name="dimSizeArray">[in] array with size (number of elements) for each dimension.
dimSizeArray must not be null and must have at least dimCount elements. Each size value must be &gt; 0.</param>
            <param name="type">[in] type of the array, default (eIsValueArray) see ArrayType.
Note: if an array of arrays is created, the main array must have the same type as the sub array.</param>
            <param name="flags">[in] bit flags for the array properties, default (eArrayPropertyUnspecified) see ArrayPropertyFlags.
Note: flags ::eHasDynamicSize, ::eHasInputQuantity, ::eHasOutputQuantity, ::eHasComparisonQuantity and ::eHasAxis only prepare the
array that these properties are available.
However, each property (e.g. axis) must be set individually by getting the IArrayInfo objects with GetArrayInfo and using the respective Set methods.</param>
            <param name="byteOffsetBase">[in] Base factor for calculation of byte offsets for each element channel from the template channel (this channel). Default is 0.
If byteOffsetBase is 0, then the byte offset is used from the size in bytes of the element channels,
i.e. component values are stored contiguously (next to each other without gaps).
If byteOffsetBase is not 0, then its absolute value should be larger than or equal to the size in bytes of the element channels.
If byteOffsetBase is negative, the component values are stored with decreasing index.</param>
            <param name="invalBitPosBase">[in] Base factor for calculation of invalidation bit positions for each element channel from the template channel (this channel). Default is 0.
Note: only used if template channel uses invalidation bits (see ::eFlagInvalBitUsed).
If invalBitPosBase is 0, then all element channels use the same invalidation bit in the record, i.e. either all are valid or all are invalid.
If invalBitPosBase &gt; 0, each element channel will have its own invalidation bit.
If invalBitPosBase is 1, then the individual invalidation bits are stored without gaps.</param>
            <returns> error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.RemoveAllAttachmentRefsTo(Vector.Mdf4LibDotNet.IAttachment)">
            <summary>
                <para>Remove all references to the given attachment</para>
                <para>note: Only available for newly created or writable file, not available for MDF &lt; 4.0 or for array child channels.</para>
                <para>This also affects the attachment reference of a channel with type eSynchronization.</para>
                <para>Keep in mind that the indices of other channel attachments may change.</para>
            </summary>
            <param name="attachment">[in] attachment object of type IAttachment (must not be null).
Note: attachment object must be in same file and in global list of attachments.</param>
            <returns>error code of the operation, eNotFound if the attachment was not referenced by this channel</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.RemoveAttachmentRef(System.UInt64)">
            <summary>
                <para>Remove attachment reference of given index</para>
                <para>note: Only available for newly created or writable file, not available for MDF &lt; 4.1 or for array child channels</para>
                <para>This does not affect the attachment reference of a channel with type eSynchronization</para>
                <para>Keep in mind that the indices of other channel attachments may change.</para>
            </summary>
            <param name="index">[in] index index of attachment in channel attachments</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointerEx(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointerEx(Vector.Mdf4LibDotNet.DataPointerOptionsFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a data pointer object to navigate and read signal data for this channel</para>
            </summary>
            <param name="flags">[in] bit combination of option flags <seealso cref="T:Vector.Mdf4LibDotNet.DataPointerOptionsFlags" /></param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetDisplayName(System.String)">
            <summary>
                <para>Set display name of channel</para>
                <para>note: only available for newly created or writable file, not available for array child channels in MDF4 files and for MDF &lt; 3.0.</para>
                <para>For MDF4, the display name is encoded in the comment, therefore setting the IComment after setting of the display name will overwrite it.</para>
            </summary>
            <param name="displayName">[in] displayName display name to be set, null or empty string if display name should be deleted.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadPhysRangeMax">
            <summary>Read maximum value of physical value range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadPhysRange(System.Double@,System.Double@)" /></summary>
            <returns>maximum value of physical value range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadPhysRangeMin">
            <summary>Read minimum value of physical value range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadPhysRange(System.Double@,System.Double@)" /></summary>
            <returns>minimum value of physical value range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadPhysRange(System.Double@,System.Double@)">
            <summary>
                <para>Read physical value range of channel</para>
                <para>Usually the physical value range stored in the conversion rule assigned to the channel will be returned.</para>
                <para>In case the physical value range of the conversion rule is not available, but the raw value range of the channel is valid:</para>
                <para>a. If the channel has no conversion rule, the raw value range will be returned.</para>
                <para>b. If the conversion rule does not return a numeric type, the raw value range will be returned and the return value will be eInvalidConversionType.</para>
                <para>c. In all other cases, the raw value range will be converted using the conversion rule:</para>
                <para> 1. On a conversion error, the return value will be the error code of the conversion operation.</para>
                <para> 2. On success it will be either eOK or eConversionNotMonotone to indicate that the phys value range may not be correct because the conversion may not be monotone.</para>
            </summary>
            <param name="minV">[out] min the minimum physical value of the range will be assigned</param>
            <param name="maxV">[out] max the maximum physical value of the range will be assigned</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetPhysRange(System.Double,System.Double,System.Boolean)">
            <summary>
                <para>Set physical value range of channel</para>
                <para>note: only available for newly created or writable file, not available for array child channels in MDF4 files</para>
                <para>Set the minimum and maximum physical value that occurred for the signal.</para>
                <para>For arrays, the minimum and maximum value is calculated over all elements.</para>
                <para>note: range should only be set if conversion rule is used exclusively for this channel.</para>
            </summary>
            <param name="minV">[in] min minimum physical value</param>
            <param name="maxV">[in] max maximum physical value</param>
            <param name="isValid">[in] isValid false if physical range is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetDefaultXChannel(Vector.Mdf4LibDotNet.IChannel)">
            <summary>
                <para>Set the channel to be preferably used as X axis</para>
                <para>note: only available for newly created or writable file, not available for MDF &lt; 4.1 or for array child channels.</para>
            </summary>
            <param name="channel">[in] channel object of type IChannel, null to remove reference to default X channel.
Note: object must be in same file.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDefaultXChannel">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetDefaultXChannel(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDefaultXChannel(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get the assigned channel to be preferably used as X axis</para>
                <para>note: the default X channel is optional and not available for MDF &lt; 4.1.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>on success the IChannel interface of the assigned default X channel is returned, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetUnit(Vector.Mdf4LibDotNet.IUnit)">
            <summary>
                <para>Set unit of channel</para>
                <para>note: only available for newly created or writable file, not available for MDF3 or for array child channels</para>
            </summary>
            <param name="unit">[in] unit object of type IUnit, null to remove reference for unit.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetConversion(Vector.Mdf4LibDotNet.IConversion)">
            <summary>
                <para>Set conversion rule of channel</para>
                <para>note: only available for newly created or writable file, not available for array child channels in MDF4 file</para>
            </summary>
            <param name="conversion">[in] conversion object of type IConversion, null to remove reference for conversion.
Note: conversion object must be in same file and match the data type of the channel.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetSourceInfo(Vector.Mdf4LibDotNet.ISourceInfo)">
            <summary>
                <para>Set source information of channel</para>
                <para>note: only available for newly created or writable file, not available for structure or array child channels</para>
            </summary>
            <param name="sourceInfo">[in] sourceInfo object of type ISourceInfo, null to remove reference to a source info object.
Note: object must be in same file.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
                <para>Set comment of channel</para>
                <para>note: only available for newly created or writable file, not available for array elements in MDF4 file</para>
            </summary>
            <param name="comment">[in] comment object of type IComment, null to remove reference to a comment object.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetSyncStreamAttachment(Vector.Mdf4LibDotNet.IAttachment)">
            <summary>
                <para>Set attachment reference for stream data related to this channel</para>
                <para>note: only available for MDF4 and channel type eSynchronization in newly created or writable file, not available for array child channels</para>
            </summary>
            <param name="attachment">[in] attachment object of type IAttachment (must not be null).
Note: attachment object must be in same file and in global list of attachments.</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.AddAttachment(Vector.Mdf4LibDotNet.IAttachment,System.UInt64@)">
            <summary>
                <para>Add attachment reference to this channel</para>
                <para>note: only available for newly created or writable file, not available for MDF &lt; 4.1 or for array child channels</para>
                <para>For setting the attachment of a synchronization channel use SetSyncStreamAttachment.</para>
            </summary>
            <param name="attachment">[in] attachment object of type IAttachment (must not be null).
Note: attachment object must be in same file and in global list of attachments.
It is not possible to add an attachment a second time for a channel.</param>
            <param name="index">[out] index the zero-based index of the added attachment in the list of channel attachments will be returned.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetFlagState(System.UInt32,System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.SetFlagState(Vector.Mdf4LibDotNet.ChannelFlags,System.Boolean)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetFlagState(Vector.Mdf4LibDotNet.ChannelFlags,System.Boolean)">
            <summary>
                <para>Set a flag state</para>
                <para>note: only available for newly created or writable file, not available for MDF3 or for array child channels</para>
            </summary>
            <param name="flag">
                <para>[in] flag flag to be set <seealso cref="T:Vector.Mdf4LibDotNet.ChannelFlags" /> for flag values.</para>
                <para>May even be a bit combination, e.g. SetFlagState(eFlagCalibration | eFlagCalculated).</para>
                <para>Note: the following flags cannot be changed with this method: eFlagInvalBitUsed, eFlagDefaultX.</para>
                <para>The following flags cannot only be reset with this method: eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid.</para>
            </param>
            <param name="state">[in] state true if the flag(s) should be set, false if they should be reset</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetPrecision(System.Byte,System.Boolean)">
            <summary>
                <para>Set the precision to use for display of floating point values</para>
                <para>note: only available for newly created or writable file, not available for MDF3 or for array child channels</para>
            </summary>
            <param name="precision">[in] precision number of decimal places to use for display of floating point values or 255 (0xFF) in case of unrestricted precision</param>
            <param name="isValid">[in] isValid false if precision is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetExtLimitRange(System.Double,System.Double,System.Boolean)">
            <summary>
                <para>Set extended limit range of channel</para>
                <para>note: physical value for numeric conversion rule, otherwise raw value.</para>
                <para>note: only available for newly created or writable file, not available for MDF3 or for array child channels</para>
            </summary>
            <param name="minV">[in] min minimum extended limit value</param>
            <param name="maxV">[in] max maximum extended limit value</param>
            <param name="isValid">[in] isValid false if extended limit range is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetLimitRange(System.Double,System.Double,System.Boolean)">
            <summary>
                <para>Set limit range of channel</para>
                <para>note: physical value for numeric conversion rule, otherwise raw value.</para>
                <para>note: only available for newly created or writable file, not available for MDF3 or for array child channels</para>
            </summary>
            <param name="minV">[in] min minimum limit value</param>
            <param name="maxV">[in] max maximum limit value</param>
            <param name="isValid">[in] isValid false if limit range is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.SetValueRange(System.Double,System.Double,System.Boolean)">
            <summary>
                <para>Set value range of channel</para>
                <para>note: only available for newly created or writable file, not available for array child channels in MDF4 files</para>
                <para>Set the minimum and maximum raw value that occurred for the signal.</para>
                <para>For arrays, the minimum and maximum value is calculated over all elements.</para>
            </summary>
            <param name="minV">[in] min minimum raw value</param>
            <param name="maxV">[in] max maximum raw value</param>
            <param name="isValid">[in] isValid false if value range is invalid, true if valid (default)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildVLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a variable length data channel as structure child member of this channel</para>
                <para>A sub channel can only be created for a parent channel with fixed length data type eByteArray
that is not an array (composition type != eIsArray) or an array member (component type != eIsArrayElement).
In case, the composition type of the parent channel will be changed to eIsStruct.
Note that the structure child member will automatically have the same source information as the parent channel.</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="name">[in] name name for the channel.</param>
            <param name="relativeByteOffset">[in] relativeByteOffset byte offset of the channel value in the data bytes of the parent channel.</param>
            <param name="channelDataType">[in] channelDataType (default value = eByteArray) data type of the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelDataType" />
For VLSD channels, the data type specifies the type of the VLSD values. Typically only string or complex data types are used for VLSD channels.</param>
            <param name="comment">[in] comment (default value = null) object of type IComment to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] unit (default value = null) object of type IUnit to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] conversion (default value = null) object of type IConversion to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="flags">[in] flags (default value = eFlagAllValuesInvalid) bit flags to set for the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelFlags" />
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] invalBitPos (default value = 0) position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildMLSDChannel(System.String,System.UInt32,Vector.Mdf4LibDotNet.IChannel,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a maximum length data channel as structure child member of this channel</para>
                <para>A sub channel can only be created for a parent channel with fixed length data type eByteArray
that is not an array (composition type != eIsArray) or an array member (component type != eIsArrayElement).
In case, the composition type of the parent channel will be changed to eIsStruct.
Note that the structure child member will automatically have the same source information as the parent channel.</para>
                <para>note: only available for newly created or writable file, not available for MDF3</para>
            </summary>
            <param name="name">[in] name name for the sub channel.</param>
            <param name="relativeByteOffset">[in] relativeByteOffset byte offset of the channel value in the data bytes of the parent channel.
Note: the byte offset within the record of the channel group will be calculated internally!</param>
            <param name="sizeChannel">[in] sizeChannel pointer to IChannel object for the size signal of the MLSD channel.
Note: object must be in same file and channel group and should return as physical values only integer values &lt;= maxByteCount.</param>
            <param name="maxByteCount">[in] maxByteCount maximum number of Bytes for MLSD channel value, i.e. number of Bytes used for the channel value in the record data bytes.</param>
            <param name="channelDataType">[in] dataType (default value = eByteArray) data type of the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelDataType" />
Typically only string or complex data types are used for MLSD channels.
If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</param>
            <param name="comment">[in] comment (default value = null) object of type IComment to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] unit (default value = null) object of type IUnit to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] conversion (default value = null) object of type IConversion to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="flags">[in] flags (default value = eFlagAllValuesInvalid) bit flags to set for the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelFlags" />
Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)
use the respective Set methods instead to set the information.</param>
            <param name="invalBitPos">[in] invalBitPos (default value = 0) position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateChildDataChannel(System.String,System.UInt32,System.UInt32,Vector.Mdf4LibDotNet.ChannelDataType,Vector.Mdf4LibDotNet.IComment,Vector.Mdf4LibDotNet.IUnit,Vector.Mdf4LibDotNet.IConversion,Vector.Mdf4LibDotNet.ChannelFlags,System.UInt32,System.Byte,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a fixed length data channel as structure child member of this channel</para>
                <para>A sub channel can only be created for a parent channel with fixed length data type eByteArray
that is not an array (composition type != eIsArray) or an array member (component type != eIsArrayElement).
In case, the composition type of the parent channel will be changed to eIsStruct.
Note that the structure child member will automatically have the same source information as the parent channel.</para>
                <para>note: only available for newly created or writable file.</para>
            </summary>
            <param name="name">[in] name name for the sub channel.</param>
            <param name="relativeByteOffset">
                <para>[in] relativeByteOffset byte offset of the channel value in the data bytes of the parent channel.</para>
                <para>Note: the byte offset within the record of the channel group will be calculated internally!</para>
            </param>
            <param name="bitCount">[in] bitCount (default value = 64) number of bits used for the channel value in the record data bytes.</param>
            <param name="channelDataType">
                <para>[in] dataType (default value = eReal_LE) data type of the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelDataType" /></para>
                <para>If number of bits does not match the data type, the method will fail with error code eInvalidDataTypeSize.</para>
            </param>
            <param name="comment">[in] comment (default value = null) object of type IComment to set for the channel.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (cn_comment.XSD).</param>
            <param name="unit">[in] unit (default value = null) object of type IUnit to set for the channel.
Note: object must be in same file and if unit is XML for MDF4, it should match the respective XML schema (cn_unit.XSD).</param>
            <param name="conversion">[in] conversion (default value = null) object of type IConversion to set for the channel.
Note: object must be in same file and the conversion type must match the channel data type.</param>
            <param name="flags">
                <para>[in] flags bit flags to set for the channel <seealso cref="T:Vector.Mdf4LibDotNet.ChannelFlags" /></para>
                <para>Note: flags eFlagPrecisionValid, eFlagValueRangeValid, eFlagLimitRangeValid, eFlagLimitExtRangeValid and eFlagDefaultX will be ignored (reset)</para>
                <para>use the respective Set methods instead to set the information.</para>
            </param>
            <param name="invalBitPos">[in] invalBitPos (default value = 0) position of invalidation bit. Will only be considered for MDF4 and if eFlagInvalBitUsed flag is set in flags.</param>
            <param name="bitOffset">[in] bitOffset (default value = 0) bit offset of the channel value in the data bytes of the parent channel. 0-7, must be 0 for all data types &gt;= eReal_LE.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>on success the IChannel interface of the created master channel, otherwise null</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointer">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointer(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Create a data pointer object to navigate and read signal data for this channel</para>
                <para>note: the extended method IChannel::CreateDataPointerEx allows to specifiy options for the created IDataPointer</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IDataPointer object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetSyncStreamAttachment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetSyncStreamAttachment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetSyncStreamAttachment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get attachment for stream data related to this channel</para>
                <para>note: only available for MDF4 and channel type eSynchronization</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IAttachment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetAttachment(System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get attachment related to this channel for given index</para>
                <para>note: attachments for channels are only available for MDF version &gt;= 4.1.
For retrieving the attachment of a synchronization channel use GetSyncStreamAttachment.</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <param name="index">[in] index index of attachment.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IAttachment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetAttachmentCount">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetAttachmentCount(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get number of attachments related to this channel</para>
                <para>note: there can be attachments for channels for MDF version &gt;= 4.1.</para>
                <para>See <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetAttachment(System.UInt64,Vector.Mdf4LibDotNet.ErrorCode@)" /></para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of attachments (0 on error or if not available, e.g. for MDF3)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(System.UInt32,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChildChannelSet(Vector.Mdf4LibDotNet.ChannelFilterFlags,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get child channel set of channel</para>
            </summary>
            <param name="filterFlags">[in] filterFlags flags for filtering, value is a bit combination of ChannelFilterFlags</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannelSet object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChannelGroup">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetChannelGroup(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetChannelGroup(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get reference to parent channel group</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IChannelGroup object, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.IsEncodedInChannelGroup(Vector.Mdf4LibDotNet.IChannelGroup,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Request if the values for this channel are encoded in the record of given channel group</para>
                <para>note: for array elements it can happen that a channel is part of the channel set retrieved for a channel group,
although its values are not encoded in the record of this channel group
(e.g. CG/DG template for MDF4 or CD block elements distributed over several CGs for MDF3).</para>
                <para>In this case use the IDataPointer returned by IChannel::CreateDataPointer of the channel instead of the one returned by IChannelGroup::CreateDataPointer</para>
                <seealso cref="M:Vector.Mdf4LibDotNet.IChannel.CreateDataPointer" />
            </summary>
            <param name="channelGroup">[in] channelGroup the channel group to check</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>true if channel value is in the record of given channel group, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetFlags">
            <summary>Get all flags of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetFlagState(Vector.Mdf4LibDotNet.ChannelFlags)" /></summary>
            <returns>all flags of channel, see <see cref="T:Vector.Mdf4LibDotNet.ChannelFlags" /></returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetFlagState(System.UInt32)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetFlagState(Vector.Mdf4LibDotNet.ChannelFlags)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetFlagState(Vector.Mdf4LibDotNet.ChannelFlags)">
            <summary>
                <para>Request a flag state</para>
                <para>note: only available for MDF4</para>
            </summary>
            <param name="flags">[in] flag <see cref="T:Vector.Mdf4LibDotNet.ChannelFlags" /> for flag values.
May even be a bit combination, e.g. GetFlagState(eFlagCalibration | eFlagCalculated)</param>
            <returns>true if flag is set (high), false otherwise</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.IsDiscrete">
            <summary>
                <para>Request if channel has discrete values and should not be interpolated</para>
                <para>note: this method not only considers the flag state for eFlagDiscrete,
but also bit signals (GetBitCount() = 1) and non-numeric data types (HasNumericDataType() = false).</para>
            </summary>
            <returns>true if channel has discrete values, false otherwise</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadExtLimitRangeMax">
            <summary>Read maximum value of extended limit range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadExtLimitRange(System.Double@,System.Double@)" /></summary>
            <returns>maximum value of extended limit range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadExtLimitRangeMin">
            <summary>Read minimum value of extended limit range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadExtLimitRange(System.Double@,System.Double@)" /></summary>
            <returns>minimum value of extended limit range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadExtLimitRange(System.Double@,System.Double@)">
            <summary>
                <para>Read extended limit range of channel</para>
                <para>note: physical value for numeric conversion rule, otherwise raw value.</para>
                <para>note: the extended limit range may not be valid</para>
            </summary>
            <param name="minVal">[out] the minimum value of the extended limit range will be assigned</param>
            <param name="maxVal">[out] the maximum value of the extended limit range will be assigned</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadLimitRangeMax">
            <summary>Read maximum value of limit range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadLimitRange(System.Double@,System.Double@)" /></summary>
            <returns>maximum value of limit range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadLimitRangeMin">
            <summary>Read minimum value of limit range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadLimitRange(System.Double@,System.Double@)" /></summary>
            <returns>minimum value of limit range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadLimitRange(System.Double@,System.Double@)">
            <summary>
                <para>Read limit range of channel</para>
                <para>note: physical value for numeric conversion rule, otherwise raw value.</para>
                <para>note: the limit range may not be valid</para>
            </summary>
            <param name="minVal">[out] the minimum limit value of the limit range will be assigned</param>
            <param name="maxVal">[out] the maximum limit value of the limit range will be assigned</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadValueRangeMax">
            <summary>Read maximum value of value range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadValueRange(System.Double@,System.Double@)" /></summary>
            <returns>maximum value of value range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadValueRangeMin">
            <summary>Read minimum value of value range of channel. For details please refer to <see cref="M:Vector.Mdf4LibDotNet.IChannel.ReadValueRange(System.Double@,System.Double@)" /></summary>
            <returns>minimum value of value range of channel, 0.0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.ReadValueRange(System.Double@,System.Double@)">
            <summary>
                <para>Read value range of channel</para>
                <para>The minimum and maximum value that occurred for a signal can be stored, e.g.</para>
                <para>for quick determination of the display range or statistics.</para>
                <para>For arrays, the minimum and maximum value is calculated over all elements.</para>
                <para>Note: for MDF4 the precision can be specified directly for the channel. This overrules a precision provided via conversion rule.
      For MDF3, the precision is stored in the channel comment (Vector proprietary extension).</para>
                <para>
                    <para>Note: the range may not be valid</para>
                </para>
            </summary>
            <param name="minVal">[out] the minimum raw value of the range will be assigned</param>
            <param name="maxVal">[out] the maximum raw value of the range will be assigned</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetPrecision(System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetPrecision(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetPrecision(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Request the precision to use for display of floating point values</para>
                <para>Note: for MDF4 the precision can be specified directly for the channel.
This overrules a precision provided via conversion rule.
For MDF3, the precision is stored in the channel comment (Vector proprietary extension).</para>
                <para>Note: the precision information is optional </para>
            </summary>
            <param name="channelOnly">[in] channelOnly if false and if the channel has no precision information, the precision information of the conversion rule will be returned as fall-back.
Otherwise only the precision information of the channel will be considered.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>number of decimal places to use for display of floating point values or 255 (0xFF) in case of error or unrestricted precision</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetUnit(System.Boolean)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetUnit(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetUnit(System.Boolean,Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get unit of channel</para>
                <para>Note: for MDF4 a unit can be specified directly for the channel.
This overrules a unit provided via conversion rule. For MDF3, a unit only can be specified via conversion rule.
Thus, for MDF3 parameter channelOnly = false can be used to get the unit from the conversion rule instead.</para>
                <para>Note: for MDF4 channel data types eMimeSample and eMimeStream, the IUnit of the channel contains the MIME type text (given by IUnit::GetName)</para>
            </summary>
            <param name="channelOnly">[in] channelOnly if false and if the channel has no unit, the unit of the conversion rule will be returned as fall-back.
Otherwise only the unit for channel will be considered.</param>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IUnit object, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetConversion">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetConversion(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetConversion(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get conversion rule of channel
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IConversion object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetInvalBitPos(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get position of invalidation bit</para>
                <para>note: optional for MDF4, not available for MDF3</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>bit position of invalidation bit, 0 on error or if not available (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetBitOffset">
            <summary>
                <para>Get bit offset for signal value in record</para>
                <para>note: The bit offset specifies the first bit (=LSB) of the signal value after Byte offset
has been applied (0 &gt;= bit offset &lt;= 7)</para>
            </summary>
            <returns>bit offset, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetByteOffset">
            <summary>
                <para>Get offset to first Byte in the data record that contains bits of the signal value.</para>
                <para>note: The offset is applied to the plain record data, i.e. skipping the record ID.</para>
            </summary>
            <returns>byte offset, 0 on error (check error code!)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetBitCount">
            <summary>
Get number of bits for signal value in record
</summary>
            <returns>bit count, 0 on error or for virtual master channels</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.HasIntegerDataType">
            <summary>
Request if data type is Integer
</summary>
            <returns>true if data type is Integer, false otherwise or on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.HasNumericDataType">
            <summary>
Request if data type is numeric
</summary>
            <returns>true if data type is numeric (some floating-point or Integer data type)</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetComponentType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetComponentType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetComponentType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get component type of channel
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>component type <see cref="T:Vector.Mdf4LibDotNet.ComponentType" /> and eComponentTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetCompositionType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetCompositionType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetCompositionType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get composition type of channel
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>composition type <see cref="T:Vector.Mdf4LibDotNet.CompositionType" /> and eCompositionTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDataType">
            <summary>
Get data type of the channel
</summary>
            <returns>data type <see cref="T:Vector.Mdf4LibDotNet.ChannelDataType" /> and eChannelDataTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetSyncType">
            <summary>
Get synchronization type of the channel
</summary>
            <returns>sync type <see cref="T:Vector.Mdf4LibDotNet.SyncType" /> and eSyncTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetType">
            <summary>
Get type of the channel
</summary>
            <returns>channel type <see cref="T:Vector.Mdf4LibDotNet.ChannelType" /> and eChannelTypeUnspec on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetSourceInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetSourceInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetSourceInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get source information of channel</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to ISourceInfo object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get comment of channel</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to IComment object, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDescription">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDescription(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get description text for channel</para>
                <para>note: in MDF4 the description is an optional XML tag. If for MDF4 more than one description is specified, the first will be returned.</para>
                <para>If no description is specified in MDF4, the first line of the plain comment text will be returned.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with description text, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDisplayName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetDisplayName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetDisplayName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get display name of channel</para>
                <para>note: the display name is optional. If for MDF4 more than one display name is specified, the first will be returned.</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with display name, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetExtendedNamePrefix">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetExtendedNamePrefix(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetExtendedNamePrefix(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get prefix for extended name</para>
                <para>note: in case of a channel from a bus message, this is the message name, otherwise the device name</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with result, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetMessageName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetMessageName(Vector.Mdf4LibDotNet.ErrorCode@,System.Int64@,System.Int64@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetMessageName(Vector.Mdf4LibDotNet.ErrorCode@,System.Int64@,System.Int64@)">
            <summary>
                <para>Get message name for channel</para>
                <para>note: the message name is stored in CE block for MDF3 and in SI block of parent CG for MDF4</para>
            </summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <param name="msgID">[out] the ID of the message will be returned, -1 if no available</param>
            <param name="msgDLC">[out] the DLC of the message will be returned, -1 if no available</param>
            <returns>pointer to string with message name, null on error or if not available</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IChannel.GetName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get name of channel
</summary>
            <param name="errorCode">[out] errorCode contains the error code of the operation</param>
            <returns>pointer to string with channel name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IChannel.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetBlockStartAddress">
            <summary>
Get start addresses of AT block
</summary>
            <returns>start address of AT block for this channel, -1 on error.</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.SetMimeType(System.String)">
            <summary>
Set or change the mime type of the attachment
<para>note: only available for newly created or writable file, not available for MDF3</para></summary>
            <param name="mimeType">[in] mime type string to be set, null to delete the mime type.</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.SetFilePath(System.String)">
            <summary>
Set or change the file path of the attachment
<para>note: only available for newly created or writable file, not available for MDF3</para>
A file path either is absolute or relative to the path of the MDF file.
Note that after changing the file path, the MD5 check sum may become invalid (possibly call UpdateCheckSumMD5 or SetCheckSumMD5)
<para>note: For embedded attachments the file name is optional. If given, it usually represents the name of the original file.</para></summary>
            <param name="filePath">[in] file path to be set, null to delete the file path (only allowed for embedded attachments)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.SetCheckSumMD5(System.Byte[],System.Boolean)">
            <summary>
Set the MD5 checksum for the attachment
<para>note: only available for newly created or writable file, not available for MDF3
This method can be used to set or change the checksum of an attachment, e.g. if it has been calculated before.
It also allows to reset (invalidate) the checksum.
Please make sure that the checksum is correct!</para></summary>
            <param name="checksum">[in] 16 Byte buffer for the 128-bit value for MD5 checksum
(of the uncompressed data if data is embedded and compressed)</param>
            <param name="isValid">[in] isValid true if the checksum is valid, false if the checksum should be invalidated</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.UpdateCheckSumMD5(Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
Calculate and update the MD5 checksum for the attachment
<para>note: only available for newly created or writable file, not available for MDF3</para><para>note: for embedded compressed data, the checksum is calculated for the uncompressed data!</para></summary>
            <param name="progressCallback">[in] for large attachments, this operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface pointer may be given which receives the progress feedback and which may
also be used to cancel the operation</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.SetComment(Vector.Mdf4LibDotNet.IComment)">
            <summary>
Set comment of attachment
<para>note: only available for newly created or writable file, not available for MDF3</para></summary>
            <param name="comment">[in] pointer to IComment object, null to remove reference to comment object.
Note: object must be in same file and if comment is XML for MDF4, it should match the respective XML schema (at_comment.XSD).</param>
            <returns>error code for the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetFilePath">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetFilePath(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetFilePath(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get file path of attachment

The file path is determined by using the file name relative to the path of the MDF file
<para>note: For embedded attachments the file name is optional. If given, usually represents the name of the original file.</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with file path, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.CalculateCheckSumMD5(Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.CalculateCheckSumMD5(System.Byte[]@,Vector.Mdf4LibDotNet.IProgressCallback)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.CalculateCheckSumMD5(System.Byte[]@,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
Calculate the MD5 checksum for the attachment
<para>note: for embedded compressed data, the checksum is calculated for the uncompressed data!</para></summary>
            <param name="checksum">[out] 16 Byte buffer for receiving the 128-bit value for MD5 checksum</param>
            <param name="progressCallback">[in] for large attachments, this operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface pointer may be given which receives the progress feedback and which may
also be used to cancel the operation</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.SaveToFile(System.String,System.Boolean,Vector.Mdf4LibDotNet.IProgressCallback)">
            <summary>
Save the attachment to a file
<para>note: be careful not to overwrite existing file (see argument overwrite)</para></summary>
            <param name="fileName">[in] name of destination file</param>
            <param name="overwrite">[in] false if an existing destination file must not be overwritten, overwrite true if if can be overwritten</param>
            <param name="progressCallback">[in] for large attachments, this operation may take some time. For feedback (e.g. progress bar),
a IProgressCallback interface pointer may be given which receives the progress feedback and which may
also be used to cancel the operation</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.ReadData(System.UInt32,System.UInt64)">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.ReadData(System.Byte[]@,System.UInt32,System.UInt32@,System.UInt64)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.ReadData(System.Byte[]@,System.UInt32,System.UInt32@,System.UInt64)">
            <summary>
Read a number of Bytes of attachment data.
<para>note: in case of compressed embedded attachment, the uncompressed data will be returned!</para></summary>
            <param name="buffer">[out] buffer to receive the read data</param>
            <param name="numberOfBytesToRead"> How much data needs to read</param>
            <param name="numberOfBytesRead">[out] if given, this argument returns the actually read size (may be less than numberOfBytesToRead)</param>
            <param name="offset">[in] offset from start of attachment data</param>
            <returns>error code of the operation, eReachedEndOfData in case not complete buffer could be read</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetEmbeddedSize">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetEmbeddedSize(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetEmbeddedSize(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Request the size of the embedded data in Bytes
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>Number of Bytes for binary embedded data (possibly compressed), 0 on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetOriginalSize">
            <summary>
Request the original size of the data
</summary>
            <returns>Original data size in Bytes, either for external file or for uncompressed data</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetCreatorInfo">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetCreatorInfo(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get info about creator of the attachment
<para>see: IFile::GetCreatorInfo, IFile::GetFileHistory</para></summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to ICreatorInfo object, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.ReadCheckSumMD5">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.ReadCheckSumMD5(System.Byte[]@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.ReadCheckSumMD5(System.Byte[]@)">
            <summary>
Read the MD5 checksum calculated for the attachment
<para>note: The MD5 check is only optional and may not be available. It is not available for MDF3.</para></summary>
            <param name="checksum">[out] 16 Byte buffer for receiving the 128-bit value for MD5 checksum
(of the uncompressed data if data is embedded and compressed)</param>
            <returns>error code of the operation</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.IsEmbedded">
            <summary>
Request if attachment is embedded
<para>see: GetType</para></summary>
            <returns>true if attachment is embedded, false otherwise</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get type of attachment
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>type of attachment, eAttachmentTypeUnspec on error. See AttachmentType</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetMimeType">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetMimeType(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetMimeType(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get MIME type of attachment
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with MIME type, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetComment">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetComment(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
Get comment of attachment
</summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to IComment object, null on error or for MDF3</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetFileName">
            <summary>For details please refer to overloaded method <see cref="M:Vector.Mdf4LibDotNet.IAttachment.GetFileName(Vector.Mdf4LibDotNet.ErrorCode@)" /></summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetFileName(Vector.Mdf4LibDotNet.ErrorCode@)">
            <summary>
                <para>Get file name of attachment</para>
                <para>note: For embedded attachments the file name is optional. If given, it is the name of the original file.</para>
                <para>The file name may contain a relative or absolute path.</para>
            </summary>
            <param name="errorCode">[out] the error code of the operation will be returned</param>
            <returns>pointer to string with file name, null on error</returns>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAttachment.GetPtr">
            <summary>
Used to get underlying C++ pointer
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IAttachment">
            <summary>
Attachment of the MDF file (external or embedded)

An attachment is a file that is either included in the MDF file as embedded attachment
or that is referenced as external attachment. Attachments were introduced with MDF4.

For MDF3, a program block (PR block) is the equivalent of an embedded attachment. There can be only one single PR block for an MDF3 file.
The MDF4Lib will model it as single attachment, however no MIME type or other information will be available.

You may also read the binary data of an attachment (embedded or external), or save the attachment to a file on hard disk.
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.IAssertCallback.Assert(System.String,System.String,System.UInt32)">
            <summary>
                <para>will be called when an assertion occurs</para>
            </summary>
            <param name="exp">[in] string with expression that caused the assertion, e.g. for display</param>
            <param name="file">[in] file name of the source file where the assertion occurred</param>
            <param name="line">[in] line number where the assertion occurred</param>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.IAssertCallback">
            <summary>
                <para>Callback interface to report assertions</para>
                <para>
For debugging, it may be useful to log the assertions to a file. This can be done
by implementing a class that derives from this interface and registration of this
class using the exported function "SetAsssertCallback":
</para>
            </summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.FieldProperties.#ctor(System.String,System.String[],System.String,System.String,System.String,Vector.Mdf4LibDotNet.FieldDataType)">
            <summary>
constructor for multi-value field
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.FieldProperties.#ctor(System.String,System.String,System.String,System.String,System.String,Vector.Mdf4LibDotNet.FieldDataType)">
            <summary>
constructor for complex single-value field
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.FieldProperties.#ctor(System.String,System.String)">
            <summary>
constructor for simple single-value field
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.ro">
            <summary>
read-only flag for field
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.fieldType">
            <summary>
type of field, see CommentFieldType
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.type">
            <summary>
data type of element content (value field). See FieldDataType
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.lang">
            <summary>
language of element content as defined in XML standard (optional), null if not specified. Example: "en-US" = English as used in the United States.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.desc">
            <summary>
description text (optional), null if not specified
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.unit">
            <summary>
string to be displayed as unit (optional), null if not specified
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.values">
            <summary>
values of field. If fieldType is eSingleValueField, the array must contain exactly one element
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldProperties.name">
            <summary>
name of field
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.FieldProperties">
            <summary>
Structure to hold field properties
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.result">
            <summary>
string or conversion as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.keyRange">
            <summary>
min/max range as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(System.Double,System.Double,Vector.Mdf4LibDotNet.IConversion)">
            <summary>
creates a key value pair mapping a min/max range to a conversion
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(System.Double,System.Double,System.String)">
            <summary>
creates a key value pair mapping a min/max range to a string
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(System.Double,System.Double,Vector.Mdf4LibDotNet.TextOrConversion)">
            <summary>
creates a key value pair mapping a min/max range to either a string or a conversion
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(Vector.Mdf4LibDotNet.ValueRange,Vector.Mdf4LibDotNet.IConversion)">
            <summary>
creates a key value pair mapping a min/max range to a conversion
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(Vector.Mdf4LibDotNet.ValueRange,System.String)">
            <summary>
creates a key value pair mapping a min/max range to a string
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion.#ctor(Vector.Mdf4LibDotNet.ValueRange,Vector.Mdf4LibDotNet.TextOrConversion)">
            <summary>
creates a key value pair mapping a min/max range to either a string or a conversion
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValueRange2TextOrConversion">
            <summary>
Structure to hold a key value pair (value range to either string or conversion)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2TextOrConversion.result">
            <summary>
string or conversion as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2TextOrConversion.key">
            <summary>
double as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Value2TextOrConversion.#ctor(System.Double,Vector.Mdf4LibDotNet.IConversion)">
            <summary>
creates a key value pair mapping a double value to a conversion
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Value2TextOrConversion.#ctor(System.Double,System.String)">
            <summary>
creates a key value pair mapping a double value to a string
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Value2TextOrConversion.#ctor(System.Double,Vector.Mdf4LibDotNet.TextOrConversion)">
            <summary>
creates a key value pair mapping a double value to either a string or a conversion
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.Value2TextOrConversion">
            <summary>
Structure to hold a key value pair (value to either string or conversion)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TextOrConversion.conversion">
            <summary>
if not null: conversion to be used
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TextOrConversion.text">
            <summary>
if not null: text to be used
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.TextOrConversion.#ctor(Vector.Mdf4LibDotNet.IConversion)">
            <summary>
Creates a TextOrConversion struct with a conversion
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.TextOrConversion.#ctor(System.String)">
            <summary>
Creates a TextOrConversion struct with a text
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.TextOrConversion">
            <summary>
Structure to hold a text or conversion (used for partial conversions types ::eValue2Text or ::eValueRange2Text)
only one of the two members is valid. If both are null, a text null pointer is assumed
Note: this is similar to a union
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2Text.result">
            <summary>
string as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2Text.keyRange">
            <summary>
min/max range as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2Text.#ctor(System.Double,System.Double,System.String)">
            <summary>
creates a key value pair mapping a min/max range to a string
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2Text.#ctor(Vector.Mdf4LibDotNet.ValueRange,System.String)">
            <summary>
creates a key value pair mapping a min/max range to a string
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValueRange2Text">
            <summary>
Structure to hold a key value pair (value range to string)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2Value.result">
            <summary>
double as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange2Value.keyRange">
            <summary>
min/max range as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2Value.#ctor(System.Double,System.Double,System.Double)">
            <summary>
creates a key value pair mapping a min/max range to a double value
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange2Value.#ctor(Vector.Mdf4LibDotNet.ValueRange,System.Double)">
            <summary>
creates a key value pair mapping a min/max range to a double value
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValueRange2Value">
            <summary>
Structure to hold a key value pair (value range to value)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange.max">
            <summary>
maximum value of the range
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueRange.min">
            <summary>
minimum value of the range
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.ValueRange.#ctor(System.Double,System.Double)">
            <summary>
creates a value range with min and max value
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValueRange">
            <summary>
Structure to hold a value range (min, max)
max must not be smaller than min
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Text2Text.result">
            <summary>
string as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Text2Text.key">
            <summary>
string as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Text2Text.#ctor(System.String,System.String)">
            <summary>
creates a key value pair mapping a string to a string
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.Text2Text">
            <summary>
Structure to hold a key value pair (string to string)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Text2Value.result">
            <summary>
double as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Text2Value.key">
            <summary>
string as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Text2Value.#ctor(System.String,System.Double)">
            <summary>
creates a key value pair mapping a string to a double value
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.Text2Value">
            <summary>
Structure to hold a key value pair (string to value)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2Text.result">
            <summary>
string as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2Text.key">
            <summary>
double as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Value2Text.#ctor(System.Double,System.String)">
            <summary>
creates a key value pair mapping a double value to a string
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.Value2Text">
            <summary>
Structure to hold a key value pair (value to string)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2Value.result">
            <summary>
double as value of the key value pair
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.Value2Value.key">
            <summary>
double as key of the key value pair
</summary>
        </member>
        <member name="M:Vector.Mdf4LibDotNet.Value2Value.#ctor(System.Double,System.Double)">
            <summary>
creates a key value pair mapping a double value to a double value
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.Value2Value">
            <summary>
Structure to hold a key value pair (value to value)
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ErrorCode">
            <summary>
Error/result codes for MDF4Lib.net operations
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidEventHierarchy">
            <summary>
invalid event hierarchy for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidEventProperties">
            <summary>
invalid event properties for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidSyncType">
            <summary>
invalid sync type
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidEventScope">
            <summary>
invalid event scope for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidEventRangeType">
            <summary>
invalid event range type for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidEventType">
            <summary>
invalid event type for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFinalizationStepNotImplemented">
            <summary>
file is unfinalized, but cannot be finalized because a required finalization step is not implemented / not supported (yet)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eUnknownFinalizationStep">
            <summary>
file is unfinalized, but cannot be finalized due to some unknown finalization step(custom step of unknown application or new standard step)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileAlreadyFinalized">
            <summary>
file already is finalized
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eUnfinalizedMdf">
            <summary>
unfinalized MDF file, must be finalized first
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNotFound">
            <summary>
not found
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eObjectStillExists">
            <summary>
object intance still exists and cannot be removed
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidChannelType">
            <summary>
invalid channel type for operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eStringTruncated">
            <summary>
input string was too long and has been truncated (warning)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eConversionNotMonotone">
            <summary>
conversion may not be monotone
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidContextForOperation">
            <summary>
context does not allow this operation, see log file for details
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInputBufferTooLarge">
            <summary>
input buffer too large, data truncated
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInputBufferTooSmall">
            <summary>
input buffer too small, rest filled with zeros
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidConversionType">
            <summary>
conversion type not allowed here
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidDataTypeSize">
            <summary>
size for data type not allowed in MDF format or not supported by MDF4 Lib
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoStructureParent">
            <summary>
unable to add child channels because parent channel cannot be a structure (array or no fixed length data type eByteArray)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoMatchingMasterChannel">
            <summary>
no master channel with required synchronization type found
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoUniqueMasterChannel">
            <summary>
master channel with same synchronization type already contained in channel group, cannot add a second one
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoUniqueIdentification">
            <summary>
channel or channel group with same identification already contained
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eParentByteRangeExceeded">
            <summary>
channel cannot be added because the Byte range of the parent element is fixed (cannot be exteded) and
is smaller than the required Byte range of channel to be added
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eObjectNotFromSameFile">
            <summary>
a given interface pointer object is not contained in this file
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileIsReadOnly">
            <summary>
file is read-only and cannot be modified (not newly created nor opened with eReadWriteExclusive)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eDataWriterExists">
            <summary>
a data writer object (IDataWriter) uses this channel group. Operation only possible after release of the data writer object.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eDataPointerExists">
            <summary>
a data object (IDataPointer or IGroupDataPointer) uses this channel group. Operation only possible after release
of the data pointer object.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileSortCycleCountDecreased">
            <summary>
cycle counters decreased during sorting (can only occur for MDF3, possibly indicates corrupt file)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileSortCycleCountIncreased">
            <summary>
cycle counters increased during sorting (can only occur for MDF3 and eFixMdf3AddRecords)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eWrongMode">
            <summary>
wrong mode for this operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eAlreadyClosed">
            <summary>
object is already closed.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInterfaceNotCompatible">
            <summary>
interface compatibility check has failed. The installed libraries are not compatible with each other.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eRequiredDllMissing">
            <summary>
a required Mdf4Lib dll is not found in the installed folder. Please copy all corresponding dlls in same folder.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eLibraryNotLicensed">
            <summary>
library is not licensed, must call GetFileManager with valid license info
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoLogSinkRegisteredForLevel">
            <summary>
no Log sink registered for this logging level
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eLogSinkNotRegistered">
            <summary>
log sink was not registered
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoInverseConversion">
            <summary>
no inverse conversion available
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eStatusStringTableEntry">
            <summary>
                <para>status string table entry found for raw value (numerical value returned as phys value might not make sense)</para>
                <para>note: numerical value returned is raw value converted by main conversion</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eLogarithmOfZero">
            <summary>
logarithm of zero
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eDivisionByZero">
            <summary>
division by zero
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eEvaluationError">
            <summary>
conversion could not be evaluated
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidConversionResult">
            <summary>
conversion result is not valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eDifferentCoversionResultType">
            <summary>
result type does not match
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoFlushSinceLastValue">
            <summary>
channel value already has been written before (Write/SetTime)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFlushNotAllValuesWritten">
            <summary>
not all channels have been written yet (detected during FlushRecord)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eContainsVLSD">
            <summary>
channel group contains a VLSD channel
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eBeforeStartOfData">
            <summary>
no data available because before first data point (value of first data point is returned)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNotInitialized">
            <summary>
not initialized
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidChannelForOperation">
            <summary>
given channel does not apply to data pointer
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eResultBufferTooSmall">
            <summary>
result buffer too small
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidDataTypeForOperation">
            <summary>
data type cannot be used for this operation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eReachedEndOfData">
            <summary>
reached end of data
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoDataAvailable">
            <summary>
no data available
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eReverseTimeStamp">
            <summary>
reverse time stamp detected during Flush or SetTime (warning only)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoConverter">
            <summary>
no converter DLL available
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNoXmlParser">
            <summary>
XML parser not available
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eParsingError">
            <summary>
some part of the format or the formula could not be parsed (format or IO error)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFatalFormatError">
            <summary>
file has invalid format
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFormatNotSupported">
            <summary>
                <para>format errors / warnings</para>
                <para>format in file not supported (no MDF, or future MDF version)</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileEmpty">
            <summary>
File is empty
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileSortError">
            <summary>
File could not be sorted
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileAlreadySorted">
            <summary>
File already was sorted
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileExists">
            <summary>
File already exists, must not overwrite!
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileAlreadyOpen">
            <summary>
File already is open (warning)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileWriteError">
            <summary>
unable to write to file
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileCreateError">
            <summary>
file could not be created
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileReadError">
            <summary>
unable to read from file
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileOpenError">
            <summary>
file could not be opened
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eFileNotFound">
            <summary>
file errors / warnings
file or file path not found
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eOperationCancel">
            <summary>
Operation was cancelled by user
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eOverflowError">
            <summary>
data type overflow error
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNotCalledFromSameThread">
            <summary>
method not called from same thread
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eIndexOutOfBound">
            <summary>
index is out of boundary
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eInvalidArgument">
            <summary>
invalid argument
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eOutOfMemoryError">
            <summary>
out of memory (new failed)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNotAvailable">
            <summary>
Functionality / element is not available for this format / this file / this object
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eNotImplemented">
            <summary>
Functionality is not implemented / not supported (yet)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eGeneralError">
            <summary>
General error
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eOK">
            <summary>
OK
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ErrorCode.eErrorCodeUnspec">
            <summary>
Unspecified error code
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CommentMergeFlags">
            <summary>
Control of merging of comment information
used by IFile::SetCommentTextAndFields and IFactory::CreateCommentEx
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eKeepExstingInformationAppendText">
            <summary>
Combination of several options to keep existing information AND append text (separated by line break)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eKeepExstingInformation">
            <summary>
Combination of several options to keep existing information (used as Default)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eUpdateCreatorInformation">
            <summary>
If set, creator information (ci attributes) are updated for all element in input XML string.
This flag should be set in case the input XML string originates from a different file.
Only relevant for IFactory::CreateCommentEx if isXml is true.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.ePreserveAdditionalInformation">
            <summary>
If set, additional information in the original comment will be preserved
(i.e. $-encoded information in MDF 3.x that is not mapped to comment fields or additional XML information in MDF 4.x).
Otherwise, the additional information will be removed.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eAppendTextWithLineBreak">
            <summary>
If set and if ::eAppendCommentText is set and if the orginal text is not empty, then a line break (\n) will be inserted before appending the plainText
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eAppendCommentText">
            <summary>
If set, and if plain comment text is given (plainText != nullptr), the text will be appended to an existing text.
If not set, and if plaingText is not null, the original text will be replaced.
See also ::eAppendTextWithLineBreak
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eRemoveCommentFields">
            <summary>
If set, and if list of comment fields is given, all fields specified in the list will be removed from the existing fields;
all other fields are preserved. This flag cannot be set together with ::eMergeCommentFields.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eMergeCommentFields">
            <summary>
If set, and if list of comment fields is given, replace existing fields and append new fields.
If not set, and if list of comment fields is given, existing fields are removed and the new fields are written.
If comment fields are not given, existing fields are always preserved.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentMergeFlags.eCommentMergeFlagsUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CommentParentType">
            <summary>
Parent of the comment
mainly relevant for MDF 4.x in case of XML comments
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentCreatorInfo">
            <summary>
Parent is an ICreatorInfo object (FH block)  =&gt; only possible for MDF 4.x
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentAttachment">
            <summary>
Parent is an IAttachment object (AT block) =&gt; only possible for MDF 4.x
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentEvent">
            <summary>
Parent is an IEvent object (EV/TR block)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentSourceInfo">
            <summary>
Parent is an ISourceInfo object (SI block) =&gt; only possible for MDF 4.x
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentConversion">
            <summary>
Parent is an IConversion object (CC block) =&gt; only possible for MDF 4.x
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentChannel">
            <summary>
Parent is an IChannel object (CN block)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentChannelGroup">
            <summary>
Parent is an IChannelGroup object (CG block)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentDataGroup">
            <summary>
Parent is a data group (DG block) =&gt; only possible for MDF 4.x,
access via IChannelGroup::GetDataGroupComment / IChannelGroup::SetDataGroupComment.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentFile">
            <summary>
Parent is the IFile object (HD block)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentParentType.eCommentParentTypeUnspec">
            <summary>
Unspecified or not relevant/available (e.g. for plain text comments or MDF 3.x)
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CommentNodeType">
            <summary>
Type of a ICommentNode object
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentNodeType.eItemNode">
            <summary>
(list) <b>item node</b>, represents a &lt;li&gt; tag (available in MDF 4.1 or higher)
<para>Note: an item node may contain comment fields, tree and list nodes</para></summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentNodeType.eListNode">
            <summary>
                <b>list node</b>, represents a &lt;list&gt; tag (available in MDF 4.1 or higher).
<para>Note: a list node may only contain item nodes</para></summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentNodeType.eTreeNode">
            <summary>
                <b>tree node</b>, represents a &lt;tree&gt; tag (available in MDF 4.0 or higher).
<para>Note: a tree node may contain comment fields, tree and list nodes</para></summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentNodeType.eRootNode">
            <summary>
                <b>root node</b>, i.e. &lt;common_properties&gt; tag in MDF 4.x
or root of comment filed for MDF 3.x (Vector proprietary extension).
Note: the root node may contain comment fields, tree and list nodes.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentNodeType.eCommentNodeTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CommentFieldType">
            <summary>
Type of a ICommentField object
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldType.eMultiValueField">
            <summary>
Multi-value field, corresponds to &lt;elist&gt; tag in MDF 4.1 or higher
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldType.eSingleValueField">
            <summary>
Single-value field, corresponds to &lt;e&gt; tag in MDF 4.x or a field in MDF 3.x (Vector proprietary extension)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldType.eCommentFieldTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.StandardFieldType">
            <summary>
Standard field type
used for IFile::GetStandardCommentFieldProperties
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.StandardFieldType.eSubject">
            <summary>
Subject field (header field in MDF3, &lt;e&gt; tag with name "subject" in MDF4)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.StandardFieldType.eProject">
            <summary>
Project field (header field in MDF3, &lt;e&gt; tag with name "project" in MDF4)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.StandardFieldType.eDepartment">
            <summary>
Department field (header field in MDF3, &lt;e&gt; tag with name "department" in MDF4)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.StandardFieldType.eAuthor">
            <summary>
Author field (header field in MDF3, &lt;e&gt; tag with name "author" in MDF4)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.StandardFieldType.eStandardFieldTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.FieldDataType">
            <summary>
Data type of a comment field
used in structure IMDF4LibStructs::FieldProperties
<para>Note: The types are a subset of the primitive data types available in XML Schema,
see http://www.w3schools.com/schema/default.asp. </para></summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeDateTime">
            <summary>
xs:dateTime to specify a date and a time in the form "YYYY-MM-DDThh:mm:ss" (seconds can contain fractional component, time zone can be added)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeTime">
            <summary>
xs:time to specify a time in the form "hh:mm:ss" (seconds can contain fractional component, time zone can be added)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeDate">
            <summary>
xs:date to specify a date in the form "YYYY-MM-DD" (time zone can be added)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeBoolean">
            <summary>
xs:boolean for a Boolean value, i.e. to specify a true or false
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeFloat">
            <summary>
xs:float for a numeric value without a fractional component
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeInteger">
            <summary>
xs:integer for a numeric value without a fractional component
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeDecimal">
            <summary>
xs:decimal for a numeric value in general
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeString">
            <summary>
xs:string for strings that can contain characters, line feeds, carriage returns, and tab characters
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FieldDataType.eFieldDataTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SyntaxVersion">
            <summary>
Syntax version for algebraic formula.
used for IFactory::CreateAlgebraicConversionEx.
<para>Note: Most operators are equal in both syntax versions, but some have a different meaning or a different notation.
For instance, ^ is used for "bitwise exclusive OR" in MDF4 whereas it previously was used as power operator in MDF3.</para>

For all differences, please refer to ASAM MCD 2MC 1.6.0 specification, section "Incompatibility of keyword FORMULA".
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyntaxVersion.eSyntaxVersionMDF4">
            <summary>
Syntax for MDF4 (ASAP2 V 1.6 / ASAM GES 1.0)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyntaxVersion.eSyntaxVersionMDF3">
            <summary>
Syntax for MDF3 (ASAP2 V 1.5)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyntaxVersion.eSyntaxVersionUnspec">
            <summary>
Unspecified. In this case, the formula is used "as is",
i.e. it is assumed that it is correct for the current MDF version.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ArrayPropertyFlags">
            <summary>
Bit flags for array properties
enum values are equal to MDF4 bit positions for ca_flags
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasLeftOpenInterval">
            <summary>
If set, the interval ranges for the class interval axes are left-open and right-closed,
i.e. [a,b] = {x | a &lt; x &lt;= b}.
If not set, the interval ranges for the class interval axes are left-closed and right-open,
i.e. [a,b] = {x | a &lt;= x &lt; b}.
Only relevant for array type ::eIsIntervalAxis
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasInverseLayout">
            <summary>
If set, the record layout is "column oriented" instead of "row oriented".
Only of the number of dimensions is more than 1.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasFixedAxis">
            <summary>
If set, the scaling axis is fixed and the axis points are stored directly in the IArrayInfo (IArrayInfo::GetFixAxisRawValues / IArrayInfo::SetFixAxisRawValues).
If not set, the scaling axis may vary over time and the axis points are stored as channel for each dimension (IArrayInfo::GetAxisChannel / IArrayInfo::SetAxisChannel).
Only relevant if ::eHasAxis is set. Can only not be set for array types ::eIsLookUp and ::eIsScalingAxis.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasAxis">
            <summary>
If set, a scaling axis can be given for each dimension of the array, either as fixed or as dynamic axis, depending on ::eHasFixedAxis flag.
Can only be set for array types ::eIsLookUp, ::eIsScalingAxis and ::eIsClassificationResult.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasComparisonQuantity">
            <summary>
If set, a channel for the comparison quantity can be specified (IArrayInfo::GetComparisonQuantityChannel / IArrayInfo::SetComparisonQuantityChannel).
Can only be set for array types ::eIsLookUp.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasOutputQuantity">
            <summary>
If set, a channel for the output quantity can be specified (IArrayInfo::GetOutputQuantityChannel / IArrayInfo::SetOutputQuantityChannel).
Can only be set for array types ::eIsLookUp.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasInputQuantity">
            <summary>
If set, a channel for the input quantity can be specified for each dimension.
In this case each dimension can have an input quantity signal (IArrayInfo::GetInputQuantityChannel / IArrayInfo::SetInputQuantityChannel).
Can only be set for array types ::eIsLookUp and ::eIsScalingAxis.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eHasDynamicSize">
            <summary>
If set, the number of scaling points for the array is not fixed but can vary over time.
In this case each dimension can have a size signal (IArrayInfo::GetDynamicSizeChannel / IArrayInfo::SetDynamicSizeChannel).
Can only be set for array types ::eIsLookUp and ::eIsScalingAxis.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayPropertyFlags.eArrayPropertyUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ArrayType">
            <summary>
MDF channel array type
enum values are equal to MDF4 enum values for ca_type
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eIsClassificationResult">
            <summary>
The array is a D-dimensional array containing classification results.
It can have scaling axes (::eIsScalingAxis) or interval axes (::eIsIntervalAxis), even mixed.
This type is not valid for MDF &lt; 4.1
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eIsIntervalAxis">
            <summary>
The array is an axis (1-dimensional vector) defining interval ranges as "axis points".
It can be referenced by one or more arrays of type ::eIsClassificationResult.
In contrast to a scaling axis (::eIsScalingAxis), an interval axis always has one element more than the number
of elements for the respective dimension of the classification result array which references it.
The elements of the class interval axis define the borders of interval ranges that are seen as axis points.
Depending on the ::eHasLeftOpenInterval flag, the intervals are defined as left-open/right-closed or left-closed/right-open.
This type is not valid for MDF &lt; 4.1
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eIsLookUp">
            <summary>
The array is a D-dimensional array with axes.
It can have input/output/comparison quantities.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eIsScalingAxis">
            <summary>
The array is a scaling axis (1-dimensional vector), possibly referenced by one or more arrays.
If referenced by an array of type ::eIsLookUp, the axis itself may have a scaling axis (e.g. for a "curve axis") and an own input quantity.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eIsValueArray">
            <summary>
The array is a simple D-dimensional value array (value block)
without axes and without input/output/comparison quantities.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ArrayType.eArrayTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.LimitType">
            <summary>
Limit type used for IFile::SetLimit
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LimitType.eTotalSizeOfBuffer">
            <summary>
Maximum size to be used for all read and write buffers of this file.
The default size for this buffer type is 64 MByte.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LimitType.eLimitTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CanReadChannelValueFlags">
            <summary>
                <para>Bit flags for options when checking if channel values can be safely read</para>
                <para>used by IDataPoiner::CanReadChannelValueAsPhysDouble</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CanReadChannelValueFlags.eCheckMultiReadUseCase">
            <summary>
If set, the check will be executed especially for MultiRead use case, otherwise only for ordinary Read use case.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CanReadChannelValueFlags.eCanReadChannelValueFlagsDefault">
            <summary>
Default means no option flags are present.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.DataPointerOptionsFlags">
            <summary>
                <para>Bit flags for options when creating an IDataPointer object</para>
                <para>used by IChannelGroup::CreateDataPointerEx and IChannel::CreateDataPointerEx</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eShowVerbalTableErrorForMultiRead">
            <summary>
If set, MultiReadPhysValueDouble methods will return error code ::eDifferentCoversionResultType if one of the channels has a verbal table that returns a string (unless ::eDisableVerbalTableError is specified)
<para>Note: the option was introduced for backward compatibility since this error has not been reported by MultiReadPhysValueDouble methods before.</para></summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eDisableVerbalTableError">
            <summary>
If set, ::eDifferentCoversionResultType will be ignored / not returned by ReadPhysValueDouble and all MultiReadPhysValueDouble methods and the numeric raw value will be used as phys value
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eDisableStatusTabWarning">
            <summary>
If set, ::eStatusStringTableEntry will be ignored/not returned by ReadPhysValueDouble and all MultiReadPhysValueDouble methods and the numeric raw value will be used as phys value
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eDisableAutoRestorePos">
            <summary>
If set, the automatic restoration of the record position after a MultiRead operation will be disabled
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eUseAutoIncrement">
            <summary>
If set, the eAutoIncrement read mode will be activated immediately
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eUseReadBuffer">
            <summary>
If set, the IDataPointer will use a read buffer for reading the records (if possible).
If not set, the records are read directly from file (less memory consumption, but possibly slower).
See also IFile::SetLimit.
This is especially useful when using the MultRead methods or for simple forward reading all all records.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataPointerOptionsFlags.eDataPointerOptionsFlagsDefault">
            <summary>
Default means no option flags are present.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.RewriteFileOptionFlags">
            <summary>
Bit flags for options when rewriting a file
used by IFileManager::RewriteFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RewriteFileOptionFlags.eOverwriteRewriteFile">
            <summary>
If set, an existing destination file will be overwritten. If not set and if destination file exists, the operation will fail.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RewriteFileOptionFlags.eRewriteFileOptionUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValidateFileOptionFlags">
            <summary>
Bit flags for options when validating a file
used by IFileManager::ValidateFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValidateFileOptionFlags.eCheckUnfinalized">
            <summary>
If set, validation will also be done for unfinalized MDF files.
Otherwise unfinalized MDF files are rejected (error code ::eUnfinalizedMdf).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValidateFileOptionFlags.eCheckXmlFragments">
            <summary>
If set, validation will check for valid XML fragments (MDF 4.x only).
Attention: XML fragments can only be checked if the respective Schema files are present in subfolder Schema/v4xx.
In case one of the Unicode variants of MDF4 Lib is used, the non-Unicode variant of XmlParser DLL is required in addition.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValidateFileOptionFlags.eCheckForGaps">
            <summary>
If set, validation will check for gaps and overlapping of blocks.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValidateFileOptionFlags.eReportWarnings">
            <summary>
If set, warnings are reported, too. Otherwise only errors are reported.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValidateFileOptionFlags.eValidateFileOptionUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.MessageTypeValidateCallback">
            <summary />
        </member>
        <member name="F:Vector.Mdf4LibDotNet.MessageTypeValidateCallback.eMessageTypeUnspecified">
            <summary />
        </member>
        <member name="T:Vector.Mdf4LibDotNet.FinalizeFileOptionFlags">
            <summary>
Bit flags for options of MDF finalization
used by IFileManager::FinalizeFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FinalizeFileOptionFlags.eTestFinalizationMode">
            <summary>
If set, the file will not be finalized immediately but only tested if it is unfinalized and if it is possible to finalize it.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FinalizeFileOptionFlags.eAlwaysSortFile">
            <summary>
If set, an unsorted (and unfinalized) file will be sorted during finalization, independent if sorting is necessary for finalization or not.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FinalizeFileOptionFlags.eOverwriteDestFile">
            <summary>
If set, an existing destination file will be overwritten. If not set and if destination file exists, the operation will fail.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FinalizeFileOptionFlags.eFinalizeFileOptionUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CreateFileOptionFlags">
            <summary>
Bit flags for options when creating a new file used by IFileManager::CreateFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CreateFileOptionFlags.eUseAsyncFileWrite">
            <summary>
If set, writing to file will be done asynchronously
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CreateFileOptionFlags.eOverwriteExistingFile">
            <summary>
If set, an existing destination file will be overwritten. If not set and if destination file exists, the operation will fail.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CreateFileOptionFlags.eCreateFileOptionUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SortFileOptionFlags">
            <summary>
Bit flags for options of MDF sorting used by IFileManager::SortFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eCheckTime">
            <summary>
If set, reverse time stamps detected during sorting are treated as error.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eDebugLogSink">
            <summary>
If set, all output messages for debug logging of MdfSort will be sent to the log sinks registered for IFileManager.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eDebugLogFile">
            <summary>
                <para>If set, debug logging is activated. A log file will be generated for the sort operation: Default is to create a new log file with the same path and base name of destination file
with postfix "_MdfSort_log.txt" appended, e.g. "A.mdf" =&gt; "A_MdfSort_log.txt".</para>
                <para>If output file is not specified or output dir is not valid, then the path and name of the MdfSort.DLL will be used with postfix "_log.txt", e.g. "MdfSort_log.txt".</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eTestSortMode">
            <summary>
                <para>If set, the file will not be sorted immediately but only tested if it requires sorting</para>
                <para>Note: currently for MDF4 files, arrays with CG template are not considered/supported yet!</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eFixMdf3GapRecords">
            <summary>
If set, gaps in an MDF3 file will be closed during sorting if there are missing records (cycle counter too high e.g. when saving records failed due to full disk)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eFixMdf3AddRecords">
            <summary>
If set, an MDF3 file will be corrected during sorting if there are additional records (cycle counter too small / missing update e.g. due to a crash)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eOverwriteDestinationFile">
            <summary>
If set, an existing destination file will be overwritten. If not set and if destination file exists, the operation will fail.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SortFileOptionFlags.eSortFileOptionUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.LogSinkLevel">
            <summary>
Categories for log messages given to ILogSink
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LogSinkLevel.eFatalError">
            <summary>
Fatal Error (Exception)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LogSinkLevel.eError">
            <summary>
Error (not critical)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LogSinkLevel.eWarning">
            <summary>
Warning
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LogSinkLevel.eInfo">
            <summary>
Information
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LogSinkLevel.eLogSinkLevelUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.LicenseLevel">
            <summary>
Categories for state of licensing
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eWriteLicense">
            <summary>
Valid read/write license
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eValidLicense">
            <summary>
Valid read license
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eTestLicense">
            <summary>
Test license (usually time restricted)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eDemoLicense">
            <summary>
Demo license
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eInvalidLicense">
            <summary>
Invalid license (expired or lib version not supported)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.LicenseLevel.eLicenseLevelUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ValueAccessMode">
            <summary>
Mode for access of values in IGroupDataPointer::Read methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueAccessMode.eGetInterpolated">
            <summary>
Get a linear interpolated value for the current time (note: for discrete signals interpolation is not used and the result is equal as for to eGetCurrent).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueAccessMode.eGetNext">
            <summary>
Get the next value
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ValueAccessMode.eGetCurrent">
            <summary>
Get the current value, i.e. the value of the previously read record for this channel group.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SeekPosMode">
            <summary>
Modes for IDataPointer::SeekPos
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekPosMode.eSeekRelative">
            <summary>
Seek relative to current position (current position + offset)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekPosMode.eSeekAbsolute">
            <summary>
Seek absolute position (offset = index)
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SeekTimeMode">
            <summary>
Modes for IDataPointer::SeekTimeNs and IDataPointer::SeekTimeSec
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekGreaterOrEqual">
            <summary>
Seek time position that is greater or equal
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekGreater">
            <summary>
Seek time position that is greater
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekLessOrEqual">
            <summary>
Seek time position that is less or equal
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekLess">
            <summary>
Seek time position that is less
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekEqual">
            <summary>
Seek time position that is equal
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SeekTimeMode.eSeekNearest">
            <summary>
Seek time position that is nearest (can be less or greater)
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.FlushCheckMode">
            <summary>
Modes for IDataWriter if to check for flush errors (no dirty bits set)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FlushCheckMode.eFlushCheckAll">
            <summary>
combination of eFlushCheckDuringFlush and eFlushCheckDuringWrite
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FlushCheckMode.eFlushCheckDuringWrite">
            <summary>
                <para>check during Write/SetTime methods and returns eNoFlushSinceLastValue in case a value has been written before and omits writing the value again.</para>
                <para>The only exception is WriteRecord: this method may also report eNoFlushSinceLastValue, but the record will be written nevertheless, thus overwriting previously set values.</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FlushCheckMode.eFlushCheckDuringFlush">
            <summary>
                <para>for write mode eAutoFlush, the automatic flush during Write/SetTime fails if not all channels are "dirty".</para>
                <para>For calling IDataWriter::FlushRecord directly, the method returns eFlushNotAllValuesWritten as warning in case not all values have been written before, but reocrd is wirtten nevertheless!</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.FlushCheckMode.eFlushCheckDisabled">
            <summary>
no check for flush errors
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.TimeCheckMode">
            <summary>
Modes for IDataWriter if and when to check for reverse time stamps
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeCheckMode.eTimeCheckDuringSetTime">
            <summary>
check during SetTime methods (returns eReverseTimeStamp in case of reverse time stamps, but time value is written nevertheless!)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeCheckMode.eTimeCheckDuringFlush">
            <summary>
check during FlushRecord/WriteRecord (returns eReverseTimeStamp in case of reverse time stamps, but record is written nevertheless!)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeCheckMode.eTimeCheckDisabled">
            <summary>
no check for reverse time stamps
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.DataWriteMode">
            <summary>
Modes for IDataWriter::Write methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataWriteMode.eAutoFlush">
            <summary>
If SetTime, WriteRecord or Write operation for a channel is called a second time for the current record,
the current record will be written (flushed) to file, a new record will be prepared
and the Write operation will set the value in the new record.
This allows subsequentually writing all values for a channel (or a number of channels).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataWriteMode.eSetValue">
            <summary>
Write operation will set/change the value in the current record
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.DataReadMode">
            <summary>
Modes for IDataPointer::Read methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataReadMode.eAutoIncrement">
            <summary>
If Read operation for a channel is called a second time for the current record,
the next record will be read and the Read operation will return the value from the newly read record.
This allows subsequentually reading all values for a channel (or a number of channels).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DataReadMode.eGetValue">
            <summary>
Read operation will return the value from the current record
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.OpenFileMode">
            <summary>
Modes for OpenFile
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.OpenFileMode.eReadWriteExclusive">
            <summary>
Read and write access, locking the file. This allows to modify (extend) an exising MDF file. Only usable with extended licensing of MDF4 Lib ("write option").
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.OpenFileMode.eReadShare">
            <summary>
Read only access, with sharing
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.OpenFileMode.eReadExclusive">
            <summary>
Read only access, locking the file
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.TimeFlags">
            <summary>
                <para>Bit flags of a time stamp</para>
                <para>enum values are equal to MDF4 bit positions for hd_time_flags</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeFlags.eFlagOffsetsValid">
            <summary>
If set, the time zone and DST offsets are valid.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeFlags.eFlagLocalTime">
            <summary>
If set, the start time stamp in nanoseconds represents the local time instead of the UTC time. In this case, time zone and DST offset must not be considered.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeFlags.eTimeFlagsUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.DeleteAttachmentFlags">
            <summary>
Bit flags for removal of an attachment
used by IFile::DeleteAttachment
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DeleteAttachmentFlags.eFlagRemoveAtReferences">
            <summary>
If set, references to the attachment (in EV or CN block) will be removed, otherwise the respective reference link will only be set to zero
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.DeleteAttachmentFlags.eFlagDeleteSecure">
            <summary>
If set, the removed attachment data is overwritten with zeros to make it unreadable
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.AttachmentFlags">
            <summary>
                <para>Bit flags of an attachment</para>
                <para>enum values are equal to MDF4 bit positions for at_flags</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentFlags.eFlagMD5CheckSumValid">
            <summary>
If set, the at_md5_checksum field contains the MD5 check sum of the data.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentFlags.eFlagCompressed">
            <summary>
If set, the embedded data is compressed using the deflate algorithm.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentFlags.eFlagEmbedded">
            <summary>
If set, the attachment data is embedded, otherwise it is contained in an external file.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags">
            <summary>
Bit flags to filter channels
used by GetChannelSubSet methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eUseBinarySearchForResultSet">
            <summary>
                <para>If set, for the IChannelSet result each call to IChannelSet::GetChannelName uses a binary search.</para>
                <para>This flag can be used to improve performance in case several calls to GetChannelName are expected.</para>
                <para>Note that the first call to GetChannelName takes longer since the channels must be sorted according to the channel names first.</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eCompareNoCase">
            <summary>
If set, the name comparison is not done case sensitive
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eUseNamePrefixAsMask">
            <summary>
If set, the name prefix is treated as search mask with wild cards.
The wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eUseChannelNameAsMask">
            <summary>
If set, the name is treated as search mask with wild cards.
The wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eAcceptIfNoExtension">
            <summary>
If set, channels without an extended name prefix are accepted even if parameter extendedNamePrefix is specified.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelSubSetFilterFlags.eSubSetFilterFlagsUnspecified">
            <summary>
Unspecified, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ChannelFilterFlags">
            <summary>
Bit flags to filter channels used by GetChannelSet methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eAllChannels">
            <summary>
bit combination to get all channels, i.e. including master channels
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eAllDataChannels">
            <summary>
bit combination to get all "data" channels, i.e. without master channels
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eUseBinarySearchForChannelName">
            <summary>
                <para>If set, for the IChannelSet result each call to IChannelSet::GetChannelName uses a binary search.</para>
                <para>This flag can be used to improve performance in case several calls to GetChannelName are expected.</para>
                <para>Note that the first call to GetChannelName takes longer since the channels must be sorted according to the channel names first.</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eExcludeNonBusEventChannels">
            <summary>
                <para>If set, channels are excluded if flag eFlagBusEvent is not set (MDF 4.1 bus logging)</para>
                <para>eExcludeNonBusEventChannels and eExcludeBusEvents must not be set together!</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eExcludeBusEventChannels">
            <summary>
If set, channels are excluded if flag eFlagBusEvent is set (MDF 4.1 bus logging)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eIncludeChildsRecursively">
            <summary>
If set, the flags eIncludeChildStructMembers and eIncludeChildArrayElements will be applied recursively
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eIncludeChildArrayElements">
            <summary>
If set, child channels of arrays will be included in the set
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eIncludeChildStructMembers">
            <summary>
If set, child channels of structures will be included in the set
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eIncludeMasterChannels">
            <summary>
If set, master channels will be included in the set, otherwise only value channels are included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFilterFlags.eChannelFilterFlagsUnspecified">
            <summary>
Default value, i.e. no flag is set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ChannelFlags">
            <summary>
                <para>Bit flags of an MDF channel</para>
                <para>enum values are equal to MDF4 bit positions for cn_flags</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagDefaultX">
            <summary>
If set, the channel references some other channel to be preferably used as X axis by IChannel::GetDefaultXChannel() (introduced in MDF 4.1)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagMonotonous">
            <summary>
If set, the values for this channel are strictly monotonously increasing/decreasing (introduced in MDF 4.1)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagBusEvent">
            <summary>
If set, this channel contains information about a bus event (introduced in MDF 4.1 for bus logging)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagVirtual">
            <summary>
If set, this channel is virtual, i.e. it is simulated by the recording tool
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagCalculated">
            <summary>
If set, the values of this channel have been calculated from other channel inputs
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagCalibration">
            <summary>
If set, the signal values of this channel correspond to a calibration object, otherwise to a measurement object
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagDiscrete">
            <summary>
If set, the signal values of this channel are discrete and must not be interpolated
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagLimitExtRangeValid">
            <summary>
If set, the extended limit range is valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagLimitRangeValid">
            <summary>
If set, the limit range is valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagValueRangeValid">
            <summary>
If set, the value range is valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagPrecisionValid">
            <summary>
If set, the precision value for display of floating-point values is valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagInvalBitUsed">
            <summary>
If set, this channel uses an invalidation bit
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagAllValuesInvalid">
            <summary>
If set, all values of this channel are invalid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelFlags.eFlagUnspecified">
            <summary>
Unspecified, i.e. no flag set
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.TimeStampType">
            <summary>
Type of time stamp
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeStampType.eLocalTimeWithOffsets">
            <summary>
Time stamp is local time, offsets are valid (not allowed in MDF4)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeStampType.eUtcTimeWithOffsets">
            <summary>
Time stamp is UTC time, offsets are valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeStampType.eLocalTime">
            <summary>
Time stamp is local time, offsets are not valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeStampType.eUtcTime">
            <summary>
Time stamp is UTC time, offsets are not valid
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.TimeStampType.eTimeStampTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.BusEventType">
            <summary>
Bus event type contained in channel group / file (available since MDF 4.1)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.BusEventType.eBusEventAndSignals">
            <summary>
Channel group contains a bus event and other signals, e.g. data frame or PDU including signal descriptions for payload
file contains at least one channel group with a bus event, but also at least one channel group that has no bus event
(eBusEventNone for CG) or a bus event and other signals (eBusEventAndSignals for CG)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.BusEventType.eBusEventPlain">
            <summary>
Channel group contains / all channel groups in the file contain only a general bus event but no other signals
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.BusEventType.eBusEventNone">
            <summary>
Channel group does not contain a bus event / none of the channel groups in the file contains a bus event
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.BusEventType.eBusEventUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ZipTypeAndLevel">
            <summary>
Type and level of compression algorithm for creation of IDataWriter
enum values combine the <see cref="T:Vector.Mdf4LibDotNet.ZipType" /> (LOWORD) and the compression level (HIWORD)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_9">
            <summary>
eTransposeDeflate with compression level 9 (best compression)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_8">
            <summary>
eTransposeDeflate with compression level 8
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_7">
            <summary>
eTransposeDeflate with compression level 7
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_6">
            <summary>
eTransposeDeflate with compression level 6
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_5">
            <summary>
eTransposeDeflate with compression level 5
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_4">
            <summary>
eTransposeDeflate with compression level 4
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_3">
            <summary>
eTransposeDeflate with compression level 3
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_2">
            <summary>
eTransposeDeflate with compression level 2
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_1">
            <summary>
eTransposeDeflate with compression level 1 (best speed)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eTransposeDeflate_Default">
            <summary>
eTransposeDeflate with default compression level
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_9">
            <summary>
eDeflate with compression level 9 (best compression)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_8">
            <summary>
eDeflate with compression level 8
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_7">
            <summary>
eDeflate with compression level 7
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_6">
            <summary>
eDeflate with compression level 6
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_5">
            <summary>
eDeflate with compression level 5
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_4">
            <summary>
eDeflate with compression level 4
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_3">
            <summary>
eDeflate with compression level 3
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_2">
            <summary>
eDeflate with compression level 2
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_1">
            <summary>
eDeflate with compression level 1 (best speed)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eDeflate_Default">
            <summary>
eDeflate with default compression level
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipTypeAndLevel.eNoCompression">
            <summary>
No compression
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ZipType">
            <summary>
Type of compression algorithm for data blocks
enum values are equal to MDF4 enum values for dz_zip_type/hl_zip_type
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipType.eTransposeDeflate">
            <summary>
transposition + deflate algorithm
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipType.eDeflate">
            <summary>
deflate algorithm
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ZipType.eZipTypeUnspec">
            <summary>
Unspecified / no compression
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.AttachmentType">
            <summary>
Type of attachment
enum values are equal to MDF4 bit positions for at_flags
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentType.eEmbeddedCompressed">
            <summary>
The attachment data is embedded and is compressed using the deflate algorithm
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentType.eEmbedded">
            <summary>
The attachment data is embedded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentType.eExternal">
            <summary>
The attachment data it is contained in an external file
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.AttachmentType.eAttachmentTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ConversionResultType">
            <summary>
Type of conversion result
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultLogZero">
            <summary>
Conversion result is always logarithm of zero error
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultDivByZero">
            <summary>
Conversion result is always division by zero
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultZero">
            <summary>
Conversion result is always zero
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultError">
            <summary>
Conversion result is always an error (e.g. parsing error for algebraic conversion)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultMixed">
            <summary>
Conversion result can be mixed, i.e. floating-point value or string
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultText">
            <summary>
Conversion result is a string
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultReal">
            <summary>
Conversion result is a floating-point value
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionResultType.eConversionResultTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ConversionType">
            <summary>
                <para>MDF conversion type</para>
                <para>enum values are equal to MDF4 enum values for cc_type</para>
                <para>special enum values for MDF3 types</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eLogarithmic">
            <summary>
Logarithmic
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eExponential">
            <summary>
Exponential
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.ePolynomial">
            <summary>
                <para>MDF 3 specific formulas</para>
                <para>Polynomial</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eText2Text">
            <summary>
Text to text tabular look-up (translation)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eText2Value">
            <summary>
Text to value tabular look-up
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eValueRange2Text">
            <summary>
Value range to text/scale conversion tabular look-up
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eValue2Text">
            <summary>
Value to text/scale conversion tabular look-up
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eValueRange2Value">
            <summary>
Value range to value tabular look-up
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eValue2ValueNoInterpol">
            <summary>
Value to value tabular look-up without interpolation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eValue2ValueInterpol">
            <summary>
Value to value tabular look-up with interpolation
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eAlgebraic">
            <summary>
Algebraic conversion (ASAM MCD-2 MC text formula)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eRational">
            <summary>
Rational conversion
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eLinear">
            <summary>
Linear conversion
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eIdentity">
            <summary>
1:1 conversion
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ConversionType.eConversionTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.RangeType">
            <summary>
                <para>MDF event range type</para>
                <para>enum values are equal to MDF4 enum values for ev_range_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RangeType.eRangeEnd">
            <summary>
Event defines the end of a range
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RangeType.eRangeBegin">
            <summary>
Event defines the beginning of a range
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RangeType.ePoint">
            <summary>
Event defines a point (single event)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.RangeType.eRangeTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.EventCause">
            <summary>
                <para>MDF event cause</para>
                <para>enum values are equal to MDF4 enum values for ev_cause</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseUser">
            <summary>
Event was caused directly by user, e.g. user input or some other interaction with GUI.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseScript">
            <summary>
Event was caused by a scripting command.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseTool">
            <summary>
Event was caused by tool-internal condition, e.g. trigger condition or re-configuration.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseError">
            <summary>
Event was caused by some error.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseOther">
            <summary>
Cause of event is not known or does not fit into given categories.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventCause.eCauseCauseUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.HierarchyType">
            <summary>
                <para>MDF hierarchy type</para>
                <para>enum values are equal to MDF4 enum values for ch_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eCalibrationRef">
            <summary>
Calibration objects referenced in function (see ASAM MCD-2 MC keyword REF_CHARACTERISTIC)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eCalibrationDef">
            <summary>
Calibration objects defined in function (see ASAM MCD-2 MC keyword DEF_CHARACTERISTIC)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eLocalVariables">
            <summary>
Local variables of function (see ASAM MCD-2 MC keyword LOC_MEASUREMENT)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eOutputVariables">
            <summary>
Output variables of function(see ASAM MCD-2 MC keyword OUT_MEASUREMENT)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eInputVariables">
            <summary>
Input variables of function(see ASAM MCD-2 MC keyword IN_MEASUREMENT)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eMapList">
            <summary>
All elements of this hierarchy level form a map list (see ASAM MCD-2 MC key word MAP_LIST)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eStructure">
            <summary>
All elements and children of this hierarchy level form a "fragmented" structure.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eFunction">
            <summary>
All children of this hierarchy level form a functional group (see ASAM MCD-2 MC keyword FUNCTION)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eGroup">
            <summary>
All elements and children of this hierarchy level form a logical group (see ASAM MCD-2 MC keyword GROUP).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.HierarchyType.eHierarchyTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CommentFieldFilterFlags">
Bit flags to filter events
used by GetCommentFieldSet
</member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldFilterFlags.eIncludeMultiValueFields">
            <summary>
If set, only multi-value comment fields will be included (corresponds to &lt;elist&gt; tag in MDF 4.1 or higher)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldFilterFlags.eIncludeSingleValueFields">
            <summary>
If set, only single-value comment fields will be included (corresponds to &lt;e&gt; tag in MDF 4.x or a field in MDF 3.x)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CommentFieldFilterFlags.eIncludeAllFieldTypes">
            <summary>
If none of the Include flags is set, all comment field types are included automatically.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ScopeType">
            <summary>
MDF scope type for events
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ScopeType.eScopeChannel">
            <summary>
Scope on channel level
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ScopeType.eScopeGroup">
            <summary>
Scope on channel group level
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ScopeType.eScopeFileGlobal">
            <summary>
Global scope (complete file)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ScopeType.eScopeTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.EventFilterFlags">
            <summary>
Bit flags to filter events
used by GetEventSet and GetEventSubSet methods
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eAcceptIfNoEventName">
            <summary>
If set, events without name are accepted in case a name filter is given, otherwise they are excluded.
Only relevant for GetEventSubSet method and if the eventName is not null.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eCompareEventNameNoCase">
            <summary>
If set, the name comparison is not done case sensitive.
Only relevant for GetEventSubSet method and if the eventName is not null.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eUseEventNameAsMask">
            <summary>
If set, the name is treated as search mask with wild cards.
Only relevant for GetEventSubSet method and if the eventName is not null.
The wildcards can be ? (question mark character) for any single character and * (asterisk character) for any number of various characters.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eExcludePostProcessingEvents">
            <summary>
If set, events marked as "post processing" event are excluded (mutual exclusive with ::eOnlyPostProcessingEvents)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eOnlyPostProcessingEvents">
            <summary>
If set, only events marked as "post processing" event are included (mutual exclusive with ::eExcludePostProcessingEvents)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eExcludeEventsWithGlobalScope">
            <summary>
If set, events with global scope are excluded (mutual exclusive with ::eOnlyEventsWithGlobalScope)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eOnlyEventsWithGlobalScope">
            <summary>
If set, only events with global scope are included (mutual exclusive with ::eOnlyEventsWithGlobalScope)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithEventCauseUser">
            <summary>
If set, events with event cause ::eEventCauseUser will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithEventCauseScript">
            <summary>
If set, events with event cause ::eEventCauseScript will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithEventCauseTool">
            <summary>
If set, events with event cause ::eEventCauseTool will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithEventCauseError">
            <summary>
If set, events with event cause ::eEventCauseError will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithEventCauseOther">
            <summary>
If set, events with event cause ::eEventCauseOther will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithSyncTypeIndex">
            <summary>
If set, events with synchronization type ::eIndexSync will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithSyncTypeDistance">
            <summary>
If set, events with synchronization type ::eDistanceSync will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithSyncTypeAngle">
            <summary>
If set, events with synchronization type ::eAngleSync will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeEventsWithSyncTypeTime">
            <summary>
flags for including only certain synchronization types
If set, events with synchronization type ::eTimeSync will be inlcuded
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeAllTriggerEventTypes">
            <summary>
If set, all trigger event types are included (::eStartRecordingTrigger, ::eStopRecordingTrigger, ::eTrigger)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeMarkerEvents">
            <summary>
If set, events with type ::eMarker will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeTriggerEvents">
            <summary>
If set, events with type ::eTrigger will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeStopRecordingTriggerEvents">
            <summary>
If set, events with type ::eStopRecordingTrigger will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeStartRecordingTriggerEvents">
            <summary>
If set, events with type ::eStartRecordingTrigger will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeAcquisitionInterruptEvents">
            <summary>
If set, events with type ::eAcquisitionInterrupt will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeRecordingInterruptEvents">
            <summary>
If set, events with type ::eRecordingInterrupt will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeRecordingEvents">
            <summary>
If set, events with type ::eRecording will be included
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventFilterFlags.eIncludeAllEventTypes">
            <summary>
if none of the Include flags for an event type is set, all event types are included automatically.
same for eIncludeEventsWithSyncTypeXXX flags: if none of these flags is set, all synchronization types are included.
same for eIncludeEventsWithEventCauseXXX flags: if none of these flags is set, all event causes are included.
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.EventType">
            <summary>
                <para>MDF event type</para>
                <para>enum values are equal to MDF4 enum values for ev_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eMarker">
            <summary>
This event type specifies a marker for a point or a range.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eTrigger">
            <summary>
This event type generally specifies an event that occurred due to some condition (except of the special
start and stop recording trigger event types).
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eStopRecordingTrigger">
            <summary>
Symmetrically to the "start recording trigger" event type, this event type specifies an event which stopped
the recording of signal values due to some condition.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eStartRecordingTrigger">
            <summary>
This event type specifies an event which started the recording of signal values due to some condition
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eAcquisitionInterrupt">
            <summary>
This event type indicates that not only the recording, but already the acquisition of the signal values has been interrupted.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eRecordingInterrupt">
            <summary>
This event type indicates that the recording has been interrupted.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eRecording">
            <summary>
This event type specifies a recording period, i.e. the first and last time a signal value could theoretically be recorded.
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.EventType.eEventTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SourceBusType">
            <summary>
                <para>Source bus type</para>
                <para>enum values are equal to MDF4 enum values for si_bus_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusUSB">
            <summary>
USB bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusEthernet">
            <summary>
Ethernet bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusKLine">
            <summary>
K-Line bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusFLEXRAY">
            <summary>
FLEXRAY bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusMOST">
            <summary>
MOST bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusLIN">
            <summary>
LIN bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusCAN">
            <summary>
CAN bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusOther">
            <summary>
Bus type does not fit into given categories or is unknown
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eBusNone">
            <summary>
No bus
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceBusType.eSourceBusTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SourceType">
            <summary>
                <para>Source type</para>
                <para>enum values are equal to MDF4 enum values for si_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceUser">
            <summary>
Source is a user interaction/input (eg for user generated events)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceTool">
            <summary>
Source is a software tool (eg for tool generated signals/events)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceIO">
            <summary>
Source is an I/O device (eg analog I/O)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceBus">
            <summary>
Source is a bus (eg. for bus monitoring)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceEcu">
            <summary>
Source is an ECU
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceOther">
            <summary>
Source type does not fit into given categories or is unknown
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SourceType.eSourceTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ComponentType">
            <summary>
MDF channel component type
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ComponentType.eIsArrayElement">
            <summary>
Element of an array
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ComponentType.eIsStructMember">
            <summary>
Member of a struct (compact structure)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ComponentType.eNoComponent">
            <summary>
No component
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ComponentType.eComponentTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.CompositionType">
            <summary>
MDF channel composition type
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CompositionType.eIsArray">
            <summary>
Array
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CompositionType.eIsStruct">
            <summary>
Struct (compact structure)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CompositionType.eNoComposition">
            <summary>
No composition
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.CompositionType.eCompositionTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.SyncType">
            <summary>
                <para>MDF synchronization types</para>
                <para>enum values are equal to MDF4 enum values for cn_sync_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eIndexSync">
            <summary>
Synchronization by index    (physical values must be zero-based index)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eDistanceSync">
            <summary>
Synchronization by distance (physical values must be meters)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eAngleSync">
            <summary>
Synchronization by angle    (physical values must be radiants)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eTimeSync">
            <summary>
Synchronization by time     (physical values must be seconds)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eNoSync">
            <summary>
No synchronization
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.SyncType.eSyncTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ChannelType">
            <summary>
                <para>MDF channel types</para>
                <para>enum values are equal to MDF4 enum values for cn_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eVirtualData">
            <summary>
Virtual data channel (introduced in MDF 4.1)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eMaximumLength">
            <summary>
Maximum length data channel (introduced in MDF 4.1)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eSynchronization">
            <summary>
Synchronization channel
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eVirtualMaster">
            <summary>
Virtual master channel
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eMaster">
            <summary>
Master channel for all signals of this group
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eVariableLength">
            <summary>
Variable length data channel
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eFixedLength">
            <summary>
Fixed length data channel
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelType.eChannelTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.ChannelDataType">
            <summary>
                <para>MDF channel data types</para>
                <para>LE = Little Endian (Intel) Byte order</para>
                <para>BE = Big Endian (Motorola) Byte order</para>
                <para>enum values are equal to MDF4 enum values for cn_data_type</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eCANOpenTime">
            <summary>
CANopen time (Based on 6 Byte CANopen Time data structure)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eCANOpenDate">
            <summary>
CANopen date (Based on 7 Byte CANopen Date data structure)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eMimeStream">
            <summary>
MIME stream (all samples of channel represent a stream with MIME content-type specified in unit of IChannel)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eMimeSample">
            <summary>
MIME sample (sample is Byte Array with MIME content-type specified in unit of IChannel)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eByteArray">
            <summary>
                <para>Complex data types</para>
                <para>Byte Array with unknown content (e.g. structure)</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eString_UTF16_BE">
            <summary>
String (UTF-16 encoded BE Byte order (Motorola), null terminated)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eString_UTF16_LE">
            <summary>
String (UTF-16 encoded LE Byte order (Intel), null terminated)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eString_UTF8">
            <summary>
String (UTF-8 encoded, null terminated)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eString_SBC">
            <summary>
                <para>String data types</para>
                <para>String (SBC, standard ASCII encoded (ISO-8859-1 Latin), null terminated)</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eReal_BE">
            <summary>
IEEE 754 floating-point format with BE Byte order (Motorola)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eReal_LE">
            <summary>
                <para>Floating-point data types</para>
                <para>IEEE 754 floating-point format with LE Byte order (Intel)</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eInteger_Signed_BE">
            <summary>
signed integer (two’s complement) with BE Byte order (Motorola)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eInteger_Signed_LE">
            <summary>
signed integer (two’s complement) with LE Byte order (Intel)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eInteger_Unsigned_BE">
            <summary>
unsigned integer with BE Byte order (Motorola)
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eInteger_Unsigned_LE">
            <summary>
                <para>Integer data types</para>
                <para>unsigned integer with LE Byte order (Intel)</para>
            </summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.ChannelDataType.eChannelDataTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
        <member name="T:Vector.Mdf4LibDotNet.XmlDataType">
            <summary>
XML data types for IMetaInfo
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlDateTime">
            <summary>
DateTime
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlTime">
            <summary>
Time
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlDate">
            <summary>
Date
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlBoolean">
            <summary>
Boolean
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlFloat">
            <summary>
Float
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlInteger">
            <summary>
Integer
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlDecimal">
            <summary>
Decimal
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlString">
            <summary>
String
</summary>
        </member>
        <member name="F:Vector.Mdf4LibDotNet.XmlDataType.eXmlDataTypeUnspec">
            <summary>
Unspecified
</summary>
        </member>
    </members>
</doc>
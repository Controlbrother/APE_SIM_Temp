/****************************************************************************\ 
 *** 
 *** File                  : fm_entry_ap.cpp
 *** 
 *** Generated by dSPACE Tools.
 *** (c) Copyright 2013, dSPACE GmbH. All rights reserved.
\****************************************************************************/

#if !defined(FM_ENTRY_AP_CPP_)
#  define    FM_ENTRY_AP_CPP_


/* -- Include directives. -- */
#  include "IOCode_Data.h"
#  include <DsApplicationInterface.h>
#  include "fm_entry_ap.h"

#  if defined(EXTERN_C_DECL)
#    undef EXTERN_C_DECL
#  endif
#  if defined(__cplusplus)
#    define EXTERN_C_DECL extern "C"
#  else
#    define EXTERN_C_DECL extern
#  endif


/* -- Variable declarations in module scope. -- */

/* Pragma to suppress GCC stack reuse which leads to problems with signal chain code */
#ifdef __GNUC__
#pragma GCC optimize "-fstack-reuse=none"
#endif

/* -- Definitions of exported functions. -- */

  void
ap_entry_Noa_Nofusion_SIDRoot_TID1(
    void) 
{
    noa_nofusion_fcnModule_SIDRoot_TID1->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS30_TID1(
    void) 
{
    noa_nofusion_fcnModule_SIDS30_TID1->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS32_TID1(
    void) 
{
    noa_nofusion_fcnModule_SIDS32_TID1->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS40_TID1(
    void) 
{
    noa_nofusion_fcnModule_SIDS40_TID1->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS42_TID1(
    void) 
{
    noa_nofusion_fcnModule_SIDS42_TID1->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS7_TIDtriggered(
    void) 
{
    noa_nofusion_fcnModule_SIDS7_TIDtriggered->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS6_TIDtriggered(
    void) 
{
    noa_nofusion_fcnModule_SIDS6_TIDtriggered->updateInputs();

}

  void
ap_entry_Noa_Nofusion_SIDS21_TID3(
    void) 
{
    noa_nofusion_fcnModule_SIDS21_TID3->updateInputs();
{
int numOfReceivedBytes = 0;
uDP_Receive_3_Status = 0;
numOfReceivedBytes = pUDP_Receive_3_DriverHandle->recvFrom(ErrorList, &uDP_Receive_3_SocketData, &uDP_Receive_3_INetAddr);
pUDP_Receive_3_DriverHandle->fromInetAddr(&uDP_Receive_3_INetAddr, uDP_Receive_3_SourceIpAsVector, sizeof(uDP_Receive_3_SourceIpAsVector), &uDP_Receive_3_SourcePort);
if (numOfReceivedBytes > 0)
{
// success
std::memcpy(uDP_Receive_3_DataVector, uDP_Receive_3_SocketData.data, 1500 * (sizeof *uDP_Receive_3_DataVector));
if (numOfReceivedBytes > 1500)
{
numOfReceivedBytes = 1500;
}
uDP_Receive_3_Status = 1;
uDP_Receive_3_NumOfReceivedBytes = numOfReceivedBytes;
}
}

}

  void
ap_entry_Noa_Nofusion_SIDS26_TID4(
    void) 
{
    noa_nofusion_fcnModule_SIDS26_TID4->updateInputs();
{
int numOfReceivedBytes = 0;
uDP_Receive_2_Status = 0;
numOfReceivedBytes = pUDP_Receive_2_DriverHandle->recvFrom(ErrorList, &uDP_Receive_2_SocketData, &uDP_Receive_2_INetAddr);
pUDP_Receive_2_DriverHandle->fromInetAddr(&uDP_Receive_2_INetAddr, uDP_Receive_2_SourceIpAsVector, sizeof(uDP_Receive_2_SourceIpAsVector), &uDP_Receive_2_SourcePort);
if (numOfReceivedBytes > 0)
{
// success
std::memcpy(uDP_Receive_2_DataVector, uDP_Receive_2_SocketData.data, 10240 * (sizeof *uDP_Receive_2_DataVector));
if (numOfReceivedBytes > 10240)
{
numOfReceivedBytes = 10240;
}
uDP_Receive_2_Status = 1;
uDP_Receive_2_NumOfReceivedBytes = numOfReceivedBytes;
}
}

}

#endif                                 /* FM_ENTRY_AP_CPP_ */
/* [EOF] */
